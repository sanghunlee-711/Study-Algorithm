# 트리순회

트리 순회는 자료구조에서 각 노드를 한번 씩 탐색하는 알고리즘을 말한다.
재귀를 이용할 수 있는 순회는 전위순회(Preorder), 중위순회(Inorder), 후위순회(Postorder)가 존재한다.

모든 순회는 ***루트 노드*** 부터 시작하며 어떤노드를 먼저 방문하는지가 달라진다.
이진트리를 탐색한다는 전제조건으로 순회를 알아보자

## 전위 순회
전위 순회는 아래의 순서를 가진다
1. 노드를 방문
2. 왼쪽 서브트리를 전위순회
3. 오른쪽 서브트리를 전위순회
를 하는 방식을 띈다.

```md
     1
    / \
   /   \
  2     \
 / \     3
4   5   / \
        6   \
              7
            / \
            8   9
```

짚어가며 생각해보자 
먼저 1(루트노드)을 방문하고 그의 왼쪽 서브트리인 2를 방뭉

2를 방문 한 뒤 2의 왼쪽 서브트리인 4를 방문
4는 좌우 서브트리가 없으므로(리프노드 이므로) 다시 2의 오른쪽 서브트리로 이동
이하 5동 동일
2의 왼쪽 오른쪽 서브트리를 모두 방문하였으니 다시 올라간다.
1의 오른쪽 서브트리로 이동하여 1의 방문하지 않은 노드(오른쪽노드)인 3을 방문
계속 동일한 방식으로 진행..

최종 방문 순서는 1,2,4,5,3,6,7,8,9 노드 순이 된다
```javascript
preorder(tree){
  방문(tree.root);
  preoder(tree.left);
  preorder(tree.right);
}
```
로 의사코드가 나타난다고 한다.

## 중위 순회
중위 순회의 순서는 
1. 왼쪽 서브트리를 중위 순회한 뒤 
2. 노드를 방문
3. 오른쪽 서브트리를 중위 순회
하는 순서를 가진다.

```md
     1
    / \
   /   \
  2     \
 / \     3
4   5   / \
        6   \
              7
            / \
            8   9
```
똑같이 단계 씩 생각해보면
1의 왼쪽 서브트리로 이동 -> 2가 존재하므로 2의 서브트리로 이동
-> 더 이상 왼쪽 서브트리가 존재하지 않아 4를 방문처리
-> 4는 오른쪽 서브트리가 없기에 다시 올라간다
-> 방문하지 않은 2의 오른쪽 트리로 이동
-> 2의 오른쪽 트리인 5는 왼쪽 서브트리가 없어 5를 방문처리
-> 2의 좌우트리를 모두 방문하여 1로 올라가고 ->
1의 왼쪽 서브트리가 모두 처리 되었으므로 1을 방문 처리
-> 1의 오른쪽 서브트리인 3으로 이동
-> 3의 왼쪽 서브트리인 6으로 이동 차일드노드가 없으므로 6 방문처리
3으로 올라가 3의 왼쪽 서브트리가 모두 처리되었으므로 방문처리
-> 3의 오른쪽 서브트리인 7로 방문 후 왼쪽 서브트리로 이동 
-> 8은 서브트리가 없으므로 방문처리
-> 7 방문처리 
-> 9방문처리
방문 순서는 4,2,5,1,6,3,8,7,9 로 됨
``` javascript
inorder(tree) {
  inorder(tree.left);
  방문(tree.root);
  inorder(tree.right);
}
```
로 표현 가능


## 후위 순회
후위 순회는
1. 왼쪽 서브트리를 후위순회
2. 오른쪽 서브트리를 후위 순회
3. 노드 방문
순서로 이루어진다.
```md
     1
    / \
   /   \
  2     \
 / \     3
4   5   / \
        6   \
              7
            / \
            8   9
```
순서를 알아보자
먼저 루트노드인 1 의 왼쪽서브트리 2로가고 그 다음 왼쪽 서브트리인 4로 간 뒤
더 이상 좌우 서브트리가 없으므로 4를 방문처리
2로 간 뒤 2의 오른쪽 서브트리로 이동
2의 오른쪽 서브트리인 5에서 좌우 서브트리가 존재하지 않으므로 5 방문처리
2의 좌우 서브트리를 모두 방문하였으므로 5를 방문처리
1의 오른쪽 서브트리로 이동 ...
순서는 4,5,2,6,8,9,7,3,1 노드 순으로 이뤄짐.
``` javascript
postorder(tree) {
  postorder(tree.left);
  postorder(tree.right);
  방문(tree.root);
}
```