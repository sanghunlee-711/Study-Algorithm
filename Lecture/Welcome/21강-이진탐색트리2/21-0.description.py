description ="""
  이진 탐색트리에서 정의한 연산 중 원소를 삭제하는 연산인 remove()는 다른 연산들 보다 조금 복잡하다.

  트리에서 리프노드가 삭제되는 경우에는 별로 할일이 많지 않지만,
  루트 노드 또는 내부노드가 삭제되는 경우 다른노드들을 이리저리 옮겨서 트리의 모습을 갖추도록 구조를 조정해야하기 때문이다.

  삭제 연산이 끝난 이후에도 당연히 트리의 모습을 유지해야하기 때문이다.
  연습문제로 구현해보자

  1. 키를 이용해서 노드를 찾는다
    - 해당키의 노드가 없으면 삭제할 것도 없음
    - 찾은 노드의 부모노드도 알고 있어야함(아래 2번때문)
  2. 찾은노드를 제거하고도 이진탐색트리성질을 만족하도록 트리의 구조를 정리한다.
    구조유지를 위해서
    삭제되는 노드가
    1. 말단(leaf) 노드인 경우 
      - 그냥 그 노드를 없애면 됨 
      - 부모노드의 링크를 조정(좌? 우 ?인지 조절하여 None값 대입 필요)
      - 삭제되는 노드가 root Node(말단 노드인경우) 그냥 self.root = None을 하고 트리를 비워주면 된다.
    2. 자식을 하나 가지고 있는 경우 -> 삭제되는 노드자리에 그 자식을 대신 배치(자식이 왼쪽? 오른쪽???, 부모노드의 링크를 조정(좌? 우 ?))
    3. 자식을 둘 가지고 있는 경우 
      - 삭제되는 노드보다 바로 다음(큰)키 를 가지는 노드를 찾아 그 노드를 삭제되는 노드자리에 대신 배치하고 이 노드를 대신 삭제
      - 만약 삭제하려는 게 root노드이면 successor (바로 다음 큰 키를 가진 노드)를 찾아야하므로 그 노드의 오른쪽키에서 왼쪽에 있는 것 중 작은 애를 찾아오면 된다.
        이때 루트  노드가 아닌 경우는 또 다르게 구현이 되는데 Successor의 parent가 바로 삭제해야할 대상이 되는 경우가 있기 때문이다.


  이진탐색 트리가 효과를 발휘할 수 없는 특수한 경우도 존재한다
    - 만약 트리가 한줄로 늘어서면(즉 모든 노드가 왼쪽 또는 오른쪽의 하나의 자식만을 가지는 경우) 노드의 개수가 n이라 할 때,
    트리의 높이(깊이) 또한 n이다.

    이 경우 특정원 소를 탐색하면 이 탐색 연산의 복잡도는 선형탐색과 동일해지게 되는데 이러면 이진탐색트리를 애써 만들필요가 없음.

    이런 것이 발생하는 이유는 원소를 삽입함에 있어서 높이를 최소화 하려는 , 트리의 좌우균형을 유지하려는 노력을 하지 않았기 때문이다.

    이런 한계를 극복하기 위해서 이진탐색트리에 추가의 제약을(만족해야만 하는 성질을) 부가한 트리들이 존재하는데 AVL trees, Red-black trees등이 있다.

"""
