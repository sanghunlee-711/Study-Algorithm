description="""
  최대 최소힙에서 하나씩 꺼내고 삭제하는 메서드를 해보고
  어디서 위 자료구조가 적용되는지 알아보자

  최대힙에서의 원소의 삭제
  1. 루트노드의 제거 - 이것이 원소들 중 최대값
  2. 트리 마지막 자리노드를 임시로 루트노드의 자리에 배치를 함 => 완전이진트리의 모양을 만들어봄
  3. 자식 노드들과의 값 비교와 아래로, 아래로 이동시켜 모든 노드에서 봤을때 임시의 값과 비교하여 작게 만듦
    - 자식은 둘 있을 수도 있는데 ,어느쪽으로 이동 ?
      ex) 오른쪽 자식이 올라온다면 왼쪽 자식보다 커야함
      그러니까 자식이 둘이 있으면 그 둘 값중 더 큰 값을 기준으로해서 임시로 배치된 노드가 아래로 이동하게됨
      만약 작은쪽으로 갔을때 반대 방향의 현재 셀렉된 노드에 비해 큰 키 값을 가진 녀석이 위로 올라가게 되면 최대힙의 성질을 만족시키지 못할 수도 있기때문(사진 참고)

  원소의 개수가 n인 최대힙에서 최대원소삭제
  -> 자식노드들고의 대소비교 최대회수: 2*log2n(왼쪽 오른쪽 자식이 있으므로 *2)
  따라서 최악복잡도 O(logn)의 삭제 연산


  최대 최소힙의 응용

  1. 우선순위큐(prority Queue)
    ->Enqueue 할 때 느슨한 정렬을 이루고 있도록 만듦 (최대힙이나 최소힙에 enqueue) : O(log2n)
    -> Dequeue 할 때 최대값을 순서대로 추출: O(logn)
    - 16강에서의 양방향 연결리스트 이용구현과 효율성 비교시 시간적 장점이 존재
  2. 힙 정렬(heap sort)
    - 정렬되지 않은 원소들을 아무순서로나 최대힙에 삽입: O(logn)
    - 삽입이 끝나면, 힙이 비게될 때까지 하나씩 삭제: O(logn)
    - 원소들이 삭제된 순서가 원소들의 정렬순서
    - 정렬 알고리즘의 복잡도: O(nlogn) -> 이론적으로 n개의 아이템을 정렬할때nlogn보다 낮을 수 없다고 증명되어서 좋은 효율을 가진것이라 판단이 가능.
"""
