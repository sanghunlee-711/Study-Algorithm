description = """
  이진 트리의 특정한 구조인 heaps에 대해서 배워보자 (이진 힙 - binary heap)
  1. 루트 노드가 언제나 최댓값 또는 최솟값을 가지는 것을 -> 최대힙 , 최소힙 이라고 부름
  2. 완전 이진트리여야함
  3. 최대 힙 내의 임의의 노드를 루트로 하는 서브뜨리 또한 최대힙임.

최대힙, 최소힙을 보면 같은 레벨에서 좌우를 비교해봤을때 크기를 가늠할 수 없으므로 '느슨한정렬'이 되어있음.

"이진 탐색트리" 와 비교해보면
1. 원소들은 완전히 크기순으로 정렬되어 있는가?
  - 이진탐색트리는 그러하나 Min,max heaps는 느슨하게 정렬되어 있음
2. 특정 키 값을 가지는 원소를 빠르게 검색할 수 있는가 ?
  -  이진 탐색트리에서는 키값을 통해서 왼쪽 오른쪽을 통해 빠르게 검색이 가능
  - heaps에서는 특정 값이 들어있는가를 검색하기 위해서 그닥 좋지 않음
3. 부가의 제약조건은 어떤 것인가 ?
  - Heaps는 이진 탐색트리에 비해서 완전이진트리여야 한다는 부가의 제약 조건이 존재함.

연산의 정의
  * init(): 빈 최대힙을 생성
  * insert(item): 새로운 원소를 삽입
  * remove(): 최대원소(root node)를 반환( 그리고 동시에 이 노드를 삭제)
  -> heaps에서는 traversal과 같은  탐색이 주목적(이득이 되는 특성이 없음)이 아닌 자료구조이기 때문에 제외

데이터 표현의 설계(배열을 이용한 이진 트리의 표현 -> 완전이진트리라는 조건을 만족하므로 배열로 사용하는 것이 자당함.)
  노드 번호 m을 기준으로
  * 왼쪽 자식의 번호: 2*m
  * 오른쪽 자식의 번호: 2*m+1
  * 부모 노드의 번호 : m//2

완전 이진트리이므로
  * 노드의 추가(배열의 끝에만 추가 + 길이 늘리면 됨)/삭제는 마지막 노드에서만.

최대힙에 원소삽임
1. 트리의 마지막 자리에 새로운 원소 임시저장(완전 이진트리 조건 만족하므로)
2. 부모 노드와 키 값을 비교하여 위로, 위로, 이동 시킴(부모노드가 자식노드보다 크다는 조건인 max heaps이므로)
-> 원소의 개수가 n인 최대힙에 새로운 원소삽임 -> 부모노드와의 대소비교 최대회수: log2n
최악복잡도: O(logn)의 삽입 연산
"""
