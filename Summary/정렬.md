# Bubble Sorting(버블 정렬)

앞에 항목이 더 크면 교환을 하고 다음항목과 비교하고 또 다음항목보다 더크면 또 교환하고 .. 이런 방식으로 진행됨

Swapping(교환)이 제일 중요 함.

기억해야할 점은 반복을 거듭할 수록 정렬해야하는 항목의 수가 감소한다는 것임.

### Swapping method in js

```jsx
function swap (arr, idx1, idx2) {
	const temp = arr[idx1];
	arr[idx1] = arr[idx2];
	arr[idx2] = temp;
}

const swap = (arr,idx1,idx2)=>{
	[arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
}
```

### Naive Solution

이렇게 하면 어째저째 작동은하나 범위를 벗어나며 undefined값도 비교하게 되고 비교했던것을 또 비교하게 되므로 비교횟수를 줄이는 것이 아니게 됨.

```jsx
function bubbleSort(arr) {
  for(let i = 0; i < arr.length; i++) {
    for(let j = 0; j < arr.length; j++) {
      if(arr[j] > arr[j+1]){
        //SWAP!!
        const temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
      }
    }
  }
  return arr;
}

bubbleSort([37,45,29,8]);
//[37,45,29,8]
//[37,29,8,45]
//[29,8,37,45]
```

### Solution

```jsx
function bubbleSort(arr) {
//뒤에서 부터 진행시키면 비교횟수를 줄일 수 있게 됨
  for(let i = arr.length; i > 0; i--) {
//i-1을 통해 비교횟수를 줄이고 undefined를 피할 수 있게 됨
    for(let j = 0; j < i-1; j++) {
			console.log(arr,arr[j], arr[j+1]);
      if(arr[j] > arr[j+1]){
        //SWAP!!
        const temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
      }
    }
	console.log("ONE PASS COMPLETE!");
  }
  return arr;
}

bubbleSort([37,45,29,8]);
//[37,45,29,8]
//[37,29,8,45]
//[29,8,37,45]
```

### ES5 Solution

```jsx
const bubbleSort = (arr) => {
  const swap =(arr, idx1, idx2) => {
    [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
  }
  
  for(let i = arr.length; i > 0; i--) {
    for(let j = 0; j < i-1; j++) {
      if(arr[j] > arr[j+1]){
        //SWAP!!
        swap(arr, j, j+1);
      }
    }
  }
  return arr;
}
```

### Optimization Version

```jsx
function bubbleSort(arr) {
	//만약 정렬이 다 되었는데도 배열의 회문이 남아있는 경우 낭비가 되므로
	//swapping을 한번도 하지 않는다면 회문을 멈출 예정임.
	let noSwaps = false;

  for(let i = arr.length; i > 0; i--) {
			noSwaps = true;
//i-1을 통해 비교횟수를 줄이고 undefined를 피할 수 있게 됨
    for(let j = 0; j < i-1; j++) {
			console.log(arr,arr[j], arr[j+1]);
      if(arr[j] > arr[j+1]){
        //SWAP!!
        const temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
				noSwaps = false;
      }
    }
	if(noSwaps) break;
  }
  return arr;
}

bubbleSort([37,45,29,8]);
```

### T.C

Best Case : O(N)

Worst Case: O(N^2)


# Selection Sorting(선택 정렬)

작은값을 한번에 하나씩 위치함

처음부터 끝까지 움직이지만 정렬된 데이터는 누적되는 중임

- 범위내에서 최소값을 찾아 제일 처음 또는 마지막에 두면서 범위를 줄여나감
- 첫번째 인자를 가장 작은값이라 여기고 저장해놓음
- 더 작은 숫자를 찾으며 배열을 전체 탐색 함
- 더 작은 값을 찾으면 저장해놓은 값을 업데이트 해줌
- 만약 최소값이 처음 시작했던 index가 아니라고 여거지면 두 값을 swapping 해 줌.
- 그리고 그 처음 시작했던 인덱스값을 높여서 탐색할 윈도우를 줄여 줌.
- 다 정렬될때까지 배열을 전체 탐색함
- 끝

### My Solution === Solution

```jsx
function selectionSort(arr) {
  for(let i = 0; i < arr.length; i++) {
    let lowest = i;
    for(let j = i+1; j < arr.length; j++){
      if(arr[j] < arr[lowest]) lowest = j;
    }
    if(lowest !== i) {
      [arr[lowest] ,arr[i]] = [arr[i],arr[lowest]];
    }
  }
  return arr;
}
selectionSort([34,27,10,19,17]);
```

### T.C

쉽다는 장점과 버블정렬에 비해 swaping하는 경우가 적으므로 메모리나 cpu를 굳이비 생각하는 특이한 케이스라면 좋음

Worst : O(N^2);


# Insertion Sort(삽입 정렬)

배열의 과반을 점차적으로 만들어 정렬을 구축하며

과반은 항상 정렬이 되어있음

한번에 가장 큰 요소나 작은 요소를 찾는게 아니라 각 요소를 취하여 정렬 되어 있는 절반 속 해당하는 위치에 배치함.

그니까 한번에 하나의 요소를 정해진 범위내의 위치에 삽입하는 것임.

### Solution

```jsx
function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let current = arr[i];
    let j;
    for (j = i - 1; j >= 0 && arr[j] > current; j--) {
      arr[j + 1] = arr[j];
    }
    //j가 이미 하나 더 작은 값으로 이동한 상태이기 때문에 j+1을 해줌
    arr[j + 1] = current;
  }
  return arr;
}
insertionSort([2,1,9,76,4]);
```

### T.C

Worst: O(N^2)

### 사용처

삽입정렬은 한부분을 정렬된 배열로 유지하고 한번에 항목을 삽입하여 작동하기 때문에 어떤 값이 들어와도 필요한 위치에 놓을 수 있게 됨.

그래서 이미 정렬된 데이터를 건드리지 않고 적절한 위치에 삽입만 하면 되는 특성때문에 라이브, 스트리밍 방식으로 들어온 데이터를 즉시입력해야하는 상황에서 편리하게 사용한다고 함.

# 합병정렬(Mergin Sort) === Divide and Conquere
노이만이 최초로 작성함.

- 분할, 정렬, 합병 이 세가지가 모두 활용됨
- 인자가 0개, 1개가 있는 배열은 이미 정렬되어 있다는 사실을 알고 시작함
- 배열을 더 작은 배열로 계속 나눠서 정렬하고 이렇게 진행함.→ 0, 1개의 요소가 될 때까지 진행함.
- 나눠진 배열들의 각 옆의 배열과의 크기를 비교해 하나의 배열로 합병을 함과 동시에 정렬을 함.

### Merge

- 두개의 정렬된 배열을 합병함
- 새 배열에 두개 배열의 요소가 다 들어가게 만들며 정렬함.
- S.C: O(N+M)

```jsx
const merge =(arr1,arr2) =>{
	let answer = [];
	let i = 0;
  let j = 0;
  const firstLen = arr1.length;
  const secondLen = arr2.length;
  
  while(i < firstLen && j < secondLen) {
    if(arr2[j] > arr1[i]) {
      answer.push(arr1[i]);
      i++;
    }else{
      answer.push(arr2[j]);
      j++;
    }
  }
  //둘 중 하나의 배열 요소가 남아있다면 한번에 다 넣기 위해서 아래 두가지 반복문 존재함.
  while(i < firstLen) {
    answer.push(arr1[i]);
    i++;
  }
  while(j < secondLen) {
    answer.push(arr2[j]);
    j++;
  }
	  
	return answer;
}
merge([1,10,50], [2,14,99,100]);//[ 1, 2, 10, 14, 50, 99, 100 ]
```

### Sorting

- 하나의 배열을 어케 반으로 나눌까
- slice메서드 추천해줌
- 재귀를 사용해서 하면 편하다고 함
- baseCase는 요소가 0개나 1개인 경우임
- 이렇게 다 짜르면 작성했던 합병(merge)함수를 사용해서 다시 합병시킴

```jsx
function mergeSort(arr){
	if(arr.length <= 1) return arr;
  let mid = Math.floor(arr.length/2);
  let left = mergeSort(arr.slice(0, mid));
  let right = mergeSort(arr.slice(mid));

  return merge(left, right);
} 

mergeSort([10,24,76,73,72,19,1,9]);
```
