# Bubble Sorting(버블 정렬)

앞에 항목이 더 크면 교환을 하고 다음항목과 비교하고 또 다음항목보다 더크면 또 교환하고 .. 이런 방식으로 진행됨

Swapping(교환)이 제일 중요 함.

기억해야할 점은 반복을 거듭할 수록 정렬해야하는 항목의 수가 감소한다는 것임.

### Swapping method in js

```jsx
function swap (arr, idx1, idx2) {
	const temp = arr[idx1];
	arr[idx1] = arr[idx2];
	arr[idx2] = temp;
}

const swap = (arr,idx1,idx2)=>{
	[arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
}
```

### Naive Solution

이렇게 하면 어째저째 작동은하나 범위를 벗어나며 undefined값도 비교하게 되고 비교했던것을 또 비교하게 되므로 비교횟수를 줄이는 것이 아니게 됨.

```jsx
function bubbleSort(arr) {
  for(let i = 0; i < arr.length; i++) {
    for(let j = 0; j < arr.length; j++) {
      if(arr[j] > arr[j+1]){
        //SWAP!!
        const temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
      }
    }
  }
  return arr;
}

bubbleSort([37,45,29,8]);
//[37,45,29,8]
//[37,29,8,45]
//[29,8,37,45]
```

### Solution

```jsx
function bubbleSort(arr) {
//뒤에서 부터 진행시키면 비교횟수를 줄일 수 있게 됨
  for(let i = arr.length; i > 0; i--) {
//i-1을 통해 비교횟수를 줄이고 undefined를 피할 수 있게 됨
    for(let j = 0; j < i-1; j++) {
			console.log(arr,arr[j], arr[j+1]);
      if(arr[j] > arr[j+1]){
        //SWAP!!
        const temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
      }
    }
	console.log("ONE PASS COMPLETE!");
  }
  return arr;
}

bubbleSort([37,45,29,8]);
//[37,45,29,8]
//[37,29,8,45]
//[29,8,37,45]
```

### ES5 Solution

```jsx
const bubbleSort = (arr) => {
  const swap =(arr, idx1, idx2) => {
    [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
  }
  
  for(let i = arr.length; i > 0; i--) {
    for(let j = 0; j < i-1; j++) {
      if(arr[j] > arr[j+1]){
        //SWAP!!
        swap(arr, j, j+1);
      }
    }
  }
  return arr;
}
```

### Optimization Version

```jsx
function bubbleSort(arr) {
	//만약 정렬이 다 되었는데도 배열의 회문이 남아있는 경우 낭비가 되므로
	//swapping을 한번도 하지 않는다면 회문을 멈출 예정임.
	let noSwaps = false;

  for(let i = arr.length; i > 0; i--) {
			noSwaps = true;
//i-1을 통해 비교횟수를 줄이고 undefined를 피할 수 있게 됨
    for(let j = 0; j < i-1; j++) {
			console.log(arr,arr[j], arr[j+1]);
      if(arr[j] > arr[j+1]){
        //SWAP!!
        const temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
				noSwaps = false;
      }
    }
	if(noSwaps) break;
  }
  return arr;
}

bubbleSort([37,45,29,8]);
```

### T.C

Best Case : O(N)

Worst Case: O(N^2)


# Selection Sorting(선택 정렬)

작은값을 한번에 하나씩 위치함

처음부터 끝까지 움직이지만 정렬된 데이터는 누적되는 중임

- 범위내에서 최소값을 찾아 제일 처음 또는 마지막에 두면서 범위를 줄여나감
- 첫번째 인자를 가장 작은값이라 여기고 저장해놓음
- 더 작은 숫자를 찾으며 배열을 전체 탐색 함
- 더 작은 값을 찾으면 저장해놓은 값을 업데이트 해줌
- 만약 최소값이 처음 시작했던 index가 아니라고 여거지면 두 값을 swapping 해 줌.
- 그리고 그 처음 시작했던 인덱스값을 높여서 탐색할 윈도우를 줄여 줌.
- 다 정렬될때까지 배열을 전체 탐색함
- 끝

### My Solution === Solution

```jsx
function selectionSort(arr) {
  for(let i = 0; i < arr.length; i++) {
    let lowest = i;
    for(let j = i+1; j < arr.length; j++){
      if(arr[j] < arr[lowest]) lowest = j;
    }
    if(lowest !== i) {
      [arr[lowest] ,arr[i]] = [arr[i],arr[lowest]];
    }
  }
  return arr;
}
selectionSort([34,27,10,19,17]);
```

### T.C

쉽다는 장점과 버블정렬에 비해 swaping하는 경우가 적으므로 메모리나 cpu를 굳이비 생각하는 특이한 케이스라면 좋음

Worst : O(N^2);