# 단일 연결 리스트
배열의 인덱스와 다르게 링크드리스트는 기차 같이 걍 노드(값을 가진)가 연결되어 있음

- 헤드는 연결리스트의 시작 노드를 가리킴
- 테일은 연결리스트의 마지막 노드를 가리킴
- 헤드 노드가 어디있는지만 알고 있을 것이며 이 헤드 노드부터 다음 두번째 노드를 알아내며 계속하여 마지막 노드까지 접근하게 됨
- 탐색 용이를 위해 길이를 가지고 있게 됨

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/00bc7d6d-4691-414c-bfbd-63f581381882/Untitled.png)

| Lists | Array |
| --- | --- |
| 인덱스 없음 | 순서대로 인덱스 존재 |
| next포인터를 통해 다음 노드와 연결 | 삽입과 삭제의 비용이 많이 듦 |
| 랜덤한 접근 불가 | 특정 인덱스에 빠르게 접근 가능 |
|  |  |
- 링크드리스트는 삽입과 제거가 쉬움따라서 임의 접근이 필요하지 않은 아주 긴데이터 세트나 많은 정보에 대해 작업하는 경우 용이함.

## With Code

### Node

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

let frist = new Node("Hi");
first.next = new Node("there");
first.next.next = new Node("how");
first.next.next.next = new Node("are");
first.next.next.next.next = new Node("you");
/*
proto는 임의 삭제
console.log(first);
Node {
  val: 'Hi',
  next: Node {
    val: 'there',
    next: Node {
      val: 'how',
      next: Node {
        val: 'are',
        next: Node {
          val: 'you',
          next: null,
        }
      },
    }
  },
}
*/
```

### Singly Linked List

### Push 메서드

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

class SinglyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const node = new Node(val);
		if(!this.head){
//아무 것도 없으면 head와 tail모두 새로운 노드를 가리키게 됨
			this.head = node;
			this.tail = this.head;
		}else{
			//현재 노드("Hello")의 tail의
			// 다음을 새로 만든 노드("GoodBye")로 업데이트 하고
			this.tail.next = node;
			// 현재의 tail을 새로만든 노드("GoodBye")로 변경 해주면 됨
			this.tail = node;
			return this;
		}
	}
}

const list = new SinglyLinkedList()
list.push("Hello");
list.push("Good Bye");
console.log("HEAD!@@",list.head.next);
/*
'HEAD!@@' Node {
  val: 'Good Bye',
  next: Node {
    val: 99,
    next: null,
    ['__proto__']: { constructor: ƒ Node() }
  }
}
*/
```

### Push 메서드 pseudo code

- 값을 인자로 받음
- 받은 값으로 새로운 노드를 만듦
- 만약 리스트의 헤드프로퍼티가 없다면 헤드와 테일을 새로 생성한 노드로 변경한다
- 만약 리스트에 요소가 존재하면 현재 노드의 tail의 next를 새로만든 노드로 업데이트하고
- 현재의 테일을 새로만든 노드로 변경한다.
- 그리고 길이를 증가 시켜준다.
- 그리고 변경된 링크드리스트를 반환해준다.

### Pop메서드

배열처럼 마지막거를 그냥 빼면 되는게 아니라 마지막 노드를 추출한 다음 테일을 다시 가리키게 만드는 것이 어려워짐

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

class SinglyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const node = new Node(val);
		if(!this.head){
			this.head = node;
			this.tail = this.head;
		}else{
			this.tail.next = node;
			this.tail = node;
			return this;
		}
	}

	traverse(){
		let current = this.head;
		while(current){
			console.log(current.val);
			current = current.next;
		}
	}

	pop(){
		if(!this.head) return undefined;
		let current = this.head;
		let newTail = current;
		//current의 next가 없을 때 까지 돌릴 거임
		while(current.next){
			//이렇게 하면 newTail이 계속 current보다
			// 하나 작은 곳에 위치하고 마지막에 되서는 
			//이동하지 않게 되므로 재 할당할 값이 남아 있을 수 있음
			newTail = current;
			current = current.next;
		}
		// tail을 새로운 테일로 매칭 시킴
		this.tail = newTail;
		this.tail.next = null;
		this.length--;
		if(this.length === 0){
		// 하나의 노드만 존재하는 경우 처리를 위함
			this.head = null;
			this.tail = null	
		}
		return current;
	}
}

const list = new SinglyLinkedList()
list.push("Hello");
list.push("Good Bye");
list.push("Good Morning");
list.traverse();
/*
'Hello'
'Good Bye'
'Good Morning'
*/
list.pop() //"Good Morning"값을 가진 노드
```

### Pop 메서드 pseudo code

- 인자 안받음
- 리스트에 노드가 없으면 undefined 리턴
- tail에 도달할때 까지 루핑 돔
- 리스트의 끝까지 따라가는 “temp”라고 하는 변수와 항상 한 노드이전것을 가리키는 “pre”라는 변수가 필요함
- temp라는 변수가 리스트의 끝에 이르렀을 때 이 pre변수가 마지막에서 두번 째 노드를 가리키게 됨.
- 길이하나 줄여줌
- 제거한 값 리턴

### Shift 메서드

제일 앞에 노드 제거 후 값 반환

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

class SinglyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const node = new Node(val);
		if(!this.head){
			this.head = node;
			this.tail = this.head;
		}else{
			this.tail.next = node;
			this.tail = node;
			return this;
		}
	}

	shift(){
		if(!this.head) return undefined;
		let removedHead = this.head;
		//Hello에서 GoodBye로 헤드를 옮김
		this.head = removedHead.next;
		this.lenth--;
		if(this.length === 0){
		//마지막 노드를 제거하고 난 뒤 tail이 노드를 가지고 있게 되는 것을 처리하기 위함.
			this.head = null;
			this.tail = null	
		}
		return removedHead;
	}
}

const list = new SinglyLinkedList()
list.push("Hello");
list.push("Good Bye");
list.push("Good Morning");
list.shift(); // {val: "Hello", next: Node}

```

### Shift 메서드 pseudo code

- 노드가 없으면 return undefined;
- 노드가 존재할 경우 현재의 헤드 속성을 변수에 저장하고
- 헤드 속성을 업데이트 한 다음 한칸 이동시킴
- 길이 하나 줄임
- 제거한 노드 반환

### Unshift 메서드

링크드리스트 제일 앞에 새로운 노드 추가

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

class SinglyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const node = new Node(val);
		if(!this.head){
			this.head = node;
			this.tail = this.head;
		}else{
			this.tail.next = node;
			this.tail = node;
			return this;
		}
	}

	unshift(val){
		const newNode = new Node(val);
		if(!this.head){
			this.head = newNode;
			this.tail = this.head;
		}else{
		//else가 없으면 마지막 노드가 자신을 가리키게 되는 아찔한 상황 발생
			newNode.next = this.head;
			this.head = newNode;
		}
		this.length++;
		return this;
	}
}

const list = new SinglyLinkedList()
list.push("Hello");
list.push("Good Bye");
list.push("Good Morning");
list.unshift("Cheers");
```

### Unshift 메서드 pseudo code

- 인자로 값을 받음
- 새로운 노드를 만듦
- 헤드가 없는 경우 헤드와 테일 모두가 새로운 노드를 가리키게함
- 노드가 이미 있는 경우 새롭게 생성된 노드의 next를 현재의 헤드값으로 설정하고 헤드가 새롭게 생성된 노드를 가리키도록 한 다음
- 길이를 1증가시킴
- 변화된 링크들 리스트를 반환


### get 메서드

인덱스나 포지션을 받아서 주어진 위치에 있는 노드를 반환하는 메서드이다.

- 0을 주면 헤드를 4를 주면 다섯번째 노드를 반환 등..

중요한 점은 주어진 숫자 만큼 리스트에서 헤드를 시작으로 계속 따라간 후 해당위치의 노드를 반환한다는 것.

그러므로 항상 위치를 기준으로 무엇인가에 접근해야하는 경우 어레이를 사용하는 것이 좋을 수 있음.

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

class SinglyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const node = new Node(val);
		if(!this.head){
			this.head = node;
			this.tail = this.head;
		}else{
			this.tail.next = node;
			this.tail = node;
			return this;
		}
		this.length++;
	}

  get(index){
    if(index < 0 || index >= this.length) return null;
    let counter = 0;
    let current = this.head;
    while(counter !== index) {
      current = current.next;
      counter++;
    }
    return current;
    
  }
}

const list = new SinglyLinkedList()
list.push("Hello");
list.push("Good Bye");
list.push("Good Morning");
list.push("<3");
list.push(":)");

const toBeNull = list.get(-3);
const toBeEmoji = list.get(3);
console.log("@@",toBeNull, toBeEmoji.val);
```

### get 메서드 pseudo code

- 인덱스를 인자로 받아야 함.
- 만약 인덱스가 0보다 작거나 길이보다 크거나 같은 경우 return null
- 루프를 통해 인덱스에 접근하여 특정 인덱스의 노드를 반환해 줌

### set 메서드

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

class SinglyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const node = new Node(val);
    this.length++;
		if(!this.head){
			this.head = node;
			this.tail = this.head;
		}else{
			this.tail.next = node;
			this.tail = node;
			return this;
		}
	}

  get(index){
    if(index < 0 || index >= this.length) return null;
    let counter = 0;
    let current = this.head;
    while(counter !== index) {
      current = current.next;
      counter++;
    }
    return current;
  }

	set(index, val){
		const foundNode = this.get(index);
		if(foundNode) {
			foundNode.val = val;
			return true;
		}
		return false;
	}
}

const list = new SinglyLinkedList()
list.push("Hello");
list.push("Good Bye");
list.push("Good Morning");
list.push("<3");
list.push(":)");

const toBeNull = list.get(-3);
const toBeEmoji = list.get(3);
console.log("@@",toBeNull, toBeEmoji.val);
```

### set 메서드 pseudo code

- 인덱스와 값을 인자로 받음
- get 메서드를 이용해서 특정 node를 찾음
- 특정 Node가 없으면 return false
- 노드가 있으면 인자로 받은 값을 통해 해당 위치 index의 노드 값을 변경해주고 return true

 

### Insert 메서드

주어진 노드를 주어진 위치에 넣어줌

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

class SinglyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const node = new Node(val);
    this.length++;
		if(!this.head){
			this.head = node;
			this.tail = this.head;
		}else{
			this.tail.next = node;
			this.tail = node;
			return this;
		}
	}

  
	pop(){
		if(!this.head) return undefined;
		let current = this.head;
		let newTail = current;
		
		while(current.next){
			newTail = current;
			current = current.next;
		}

		this.tail = newTail;
		this.tail.next = null;
		this.length--;
		if(this.length === 0){
			this.head = null;
			this.tail = null	
		}
		return current;
	}
  
	unshift(val){
		const newNode = new Node(val);
		if(!this.head){
			this.head = newNode;
			this.tail = this.head;
		}else{
			newNode.next = this.head;
			this.head = newNode;
		}
		this.length++;
		return this;
	}
  
	shift(){
		if(!this.head) return undefined;
		let removedHead = this.head;
		this.head = removedHead.next;
		this.lenth--;
		if(this.length === 0){
			this.head = null;
			this.tail = null	
		}
		return removedHead;
	}

  get(index){
    if(index < 0 || index >= this.length) return null;
    let counter = 0;
    let current = this.head;
    while(counter !== index) {
      current = current.next;
      counter++;
    }
    return current;
  }
  
  set(index, val) {
    const foundNode = this.get(index);
    if(foundNode){
      foundNode.val = val;
      return true
    }
    return false;
  }
  
  insert(index, val) {
    if(index < 0 || index> this.length) return false;
    if(index === this.length) return !!this.push(val);
    if(index === 0) return !!this.unshift(val);

    const newNode = new Node(val);
    const previous = this.get(index - 1);
    const temp = previous.next;
    previous.next = newNode;
    newNode.next = temp;
    this.length++;
    return true;
  }
}

const list = new SinglyLinkedList()
list.push("Hello");
list.push("Good Bye");
list.push("Good Morning");
list.push("<3");
list.insert(0,"FIRST");
list.insert(5,"LAST");
console.clear();
console.log("true",list.insert(6,"TRUE"));
console.log("false",list.insert(100,"FALSE"));
```

### Insert 메서드 pseudo code

- 범위를 벗어난 경우 삽입 불가이므로 인덱스가 0 보다 작거나 리스트의 길이보다 큰 경우 false반환
- 인덱스가 길이와 같으면 push메서드 활용하면 됨
- index가 0 이면 unshift메서드 활용하면 됨
- 이제 get메서드를 활용해서 인덱스를 받아오고 그 index의 하나 전 노드(index-1)에 접근하면 됨
- 그 접근한 노드에 next속성을  새로운노드로 업데이트 하고
- 그리고 새로운 노드의 next속성을 인덱스로 받아온 노드에 연결하면 됨
- 길이 올림
- return true(실패하면 false)

PS: !!는 불리안 연산자로 true로 판단되면 true, false로 판단되면 false를 리턴해줌(Boolean()이랑 비슷)


### Remove 메서드

특정 포지션의 노드를 지워줌

```jsx
remove(index){
	if(index < 0 || index > this.length) return undefined;
	if(index === 0) return this.shift();
	if(index === this.length - 1) return this.pop();
	const previousNode = this.get(index-1);
	const removed = previousNode.next;
	previousNode.next = removed.next;
	this.length--;
	return removed;
}
```

### Remove 메서드 pseudo code

- 인덱스 값이 0 보다 작거나 리스트 길이 보다 큰 경우 return undefined
- 만약 인덱스가 길이-1과 같으면 pop
- 인덱스가 0 이면 shift메서드 사용
- 그렇지 않다면 get 메서드를 사용해서 index -1의 노드로 접근
- 접근한 노드의 next를 next.next노드로 바꿔줌
- 길이하나 줄임
- 제거 된 노드값을 반환

### Reverse 메서드

특정 포지션의 노드를 지워줌

```jsx
reverse(){
	let node = this.head;
	this.head = this.tail;
	this.tail = node;
	let prev = null, next = null;

	for(let i = 0; i < this.length; i++) {
		next = node.next;
		node.next = prev;
		prev = node;
		node = next;		
	}
	return this;
}
print() {
	let arr = [];
	let current = this.head;
	while(current){
		arr.push(current.val);
	}
	return arr;
}

```

### Reverse 메서드 pseudo code

- 헤드와 테일을 바꾼다
- next, ,current(head로 initializing) ,prev라는 변수를 만듦
- 리스트 루프 돌면서 current의 next를  next 변수로 설정
- current의 next를 이전에 바로 앞에있던 노드를 가리키도록 설정
- current의 node값을 prev에 저장하고 current의 next속성을 prev로 만들어줌

### 빅오 복잡도

- Insertion: O(1)
- Removal: O(1)[제일 앞인경우] or O(N)[pop인 경우 전체리스트를 따라가야 하므로]
- Searching: O(N)
- Access: O(N)

→ 정리하자면 단방향 연결리스트가 삽입과삭제의 경우 배열에 비해 유리

임의 접근이 없거나 주어진 순서대로 데이터 관리 또는 순서대로 데이터에 접근한다면 단방향 연결리스트가 유리

# Doubly Linked List(이중 연결 리스트)

- 거의 Singly Linked와 유사함
- 배열과 유사하나 다름
- 테일 헤드 있음
- 모든 노드가 next, previous attributes가 있음.
- 유연성이 더 있는 만큼 메모리가 많이 듦(next+previous를 저장해야 함으로)

## 기본 구조 만들기

```jsx
class Node {
	constructor(val){
		this.val = val;
		this.next = null;
		this.prev = null;
	}
}

class DoublyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}
}
```

## Push

노드나 값을 이중연결리스트에 추가

## Push pseudocode

- 값을 가지는 새로운 노드 만들기
- 헤드가 null인지 아니면 길이가 0 인지 확인(리스트가 비어있는지)
    - 비어 있으면 head,tail이 모두 새로운 노드로 설정
    - 비어 있지 않다면 현재 양방향 리스트의 테일의 next 속성에 새로운 노드를 추가
    - 그리고 새로운 노드의 prev속성에 테일을 추가
- 길이를 1 올려줌
- 변경된 Doubly Linked List를 반환

```jsx
push(val){
	const newNode = new Node(val);
	if(!this.length){
		this.head = newNode;
		this.tail = newNode;
	} else{
		this.tail.next = newNode;
		newNode.prev = this.tail;
		this.tail = newNode;
	}
	this.length++;
	return this;
}
```

## Pop

제일 뒤에 있는 노드 제거

## Popping pseudocode

- 헤드(테일)이 없다면 return undefined
    - 테일을 나중에 출력하도록 변수에 저장
    - 길이가 0 이라면 헤드와 테일이 둘다 null이 되도록 설정
    - 테일이 그 전에 있던 노드가 되도록 설정(prev)
    - 새로운 tail의 next 속성을 null로 설정
- 길이를 줄임
- 제거한 노드를 리턴!

```jsx
pop(){
	if(!this.head || !this.tail){
		return undefined;
	}
	const poppedNode = this.tail;
	if(this.length === 1){
		this.head = null;
		this.tail = null;
	} else{
		this.tail = poppedNode.prev;
		this.tail.next = null;
		//안하면 list에서는 연결이 끊겨도 pop한 노드에서의 연결이 남아있게 됨.
		poppedNode.prev = null;
	}
	this.length--;
	return poppedNode;
}
```

## Shift

맨 앞의 노드 하나 제거

## Shifting pseudocode

- 길이가 0인지 확인하고
    - 길이 0 이면 return undefined;
    - 아니면 현재 헤드 노드를 변수(oldHead)에 저장
    - 길이가 1이면
        - head, tail을 null로 변경
    - 길이가 1보다 크면 헤드를 oldHead.next의 노드로 변경
    - 그리고 업데이트한 헤드의 prev 속성을 null로 변경
    - oldHead의 next를 null로 변경
    - 길이 1 줄이기
    - oldHead를 반환

```jsx
shift(){
	if(!this.length) return undefined;
	const oldHead = this.head;

	if(this.length === 1){
		this.head = null;
		this.tail = null;
	}else{
		this.head = oldHead.next;
		this.head.prev = null;
		oldHead.next = null;
	}

	this.length--;
	return oldHead;
}
```

## Unshift

제일 앞에 노드하나 추가

## Unshifting pseudocode

- 받은 값으로 새로운 노드 생성
- 길이가 0 이라면 비어있으므로
    - head, tail을 새로운 노드로 설정
- 길이가 0이 아니면 head 노드의 prev 속성을 새로운 노드로
    - 새로운 노드의 next프로퍼티를 head노드로 맞춰주면 됨
    - 그리고 head를 새로운 노드로 변경
- 길이 1 증가
- 리스트 반환

```jsx
unshift(val){
	const newNode = new Node(val);
	if(!this.length){
		this.head = newNode;
		this.tail = newNode;
	}else{
		this.head.prev = newNode;
		newNode.next = this.head;
		this.head = newNode;
	}
	this.length++;
	return this;
}
```

## Get

숫자(인덱스)를 입력하여 해당 위치(인덱스)의 노드를 찾아내는 것

- 단일연결리스트는 처음부터 해당 숫자까지 회문을 돌았어야함
- 양방향은 prev도 있기때문에 앞, 뒤 모두에서 회문을 돌릴 수 있기때문에 요구되는 Index에따라 회문 시작 위치를 바꿔주면 단일연결리스트보다는 최적화가 되는 것.

## Get pseudocode

- 인덱스가 0 보다 작거나 길이보다 크면 return null;(길이랑 같아도 안되는건 인덱스이니까 안됨)
- 인덱스가 길이의 절반보다 작거나 같으면
    - head부터 middle까지 루프를 돌고 찾은 노드 반환
- 인덱스가 길이의 절반보다 크면
    - tail부터 middle까지 루프를 돌아서 찾은노드 반환

### No-Optimize

```jsx
get(index){
	if(index < 0 || index >= this.length)return null;
	const count = 0;
	const current = this.head;
	while(count != index){
		current = current.next;
		count++;
	}
	return current;
}
```

### Optimize

```jsx
get(index){
	if(index < 0 || index >= this.length)return null;
	const count = 0;
	const current = this.head;

	if(index <= this.length/2){
		const count = 0;
		const current = this.head;		
		while(count != index){
			current = current.next;
			count++;
		}
	}else{
		const count = this.length - 1;
		const current = this.head;		
		while(count != index){
			current = current.prev;
			count--;
		}
	}

	return current;
}
```

## Set

받은 인덱스의 노드 값을 받은 값으로 변경하는 것

## Set pseudocode

- get 메서드를 통해 받은 노드를 변수에 저장
    - get메서드가 유효한 노드를 반환하면 그 노드의 값을 받은 인자의 값으로 변경
    - return true
    - 유효하지 않은 노드 반환 시 return false

```jsx
set(index, val){
	const foundNode = this.get(index);
	if(foundNode !== null){
		foundNode.val = val;
		return true;
	}
	return false;
}
```

## Insert

위치를 나타내는 인덱스와 값하나를 넣고 해당 인덱스에 새로운 값으로 만든 노드를 넣음.

## Insert pseudocode

- 인덱스가 0 보다 작거나 길이보다 큰 경우 Return false
- 0이면 unshift
- 인덱스가 길이랑 같으면 Push
- 이 경우가 아니면 get메서드를 index-1한 값으로 가져오기
- next와 prev 속성을 사용해서 노드들을 연결해줌
- 길이를 1 올리고
- return true

```jsx
insert(index,val){
	if(index < 0 || index > this.length) return false;
	if(index === 0) return !!this.unshift(val);
	if(index === this.length) return !!this.push(val);

	const newNode = new Node(val);
	const beforeNode = this.get(index-1);
	const afterNode = beforeNode.next;

	beforeNode.next = newNode, newNode.prev = beforeNode;
	newNode.next = afterNode, afterNode.prev = newNode;
	this.length++;
	return true;
}
```

## Remove

특정 위치의 노드 삭제

## Remove pseudocode

- 인덱스 유효성 확인(0보다 작은지 길이보다 큰지)
    - 유효하지 않으면 return undefined
    - 인덱스 0 ⇒ shift
    - 길이-1과 같으면 ⇒ pop
    - 나머지는 get메서드를 사용해서 제거해야할 요소를 찾음
        - 그러고 next,prev를 바꿔서 요소를 잘 매꿔줌
        - 찾아낸 노드의 next,prev를 null로 바꾸고
        - 길이 1 줄이고
        - 찾아낸 노드를 반환

```jsx
remove(index){
	if(index < 0 || index >= this.length) return undefined;	
	if(index === 0) return this.shift();
	if(index === this.length - 1) return this.pop();

	const removedNode = this.get(index);
	const beforeNode = removedNode.prev;
	const afterNode = removedNode.next;

	beforeNode.next = afterNode;
	afterNode.prev= beforeNode;
	removedNode.next = null;
	removedNode.prev = null;
	this.length--;

	return removedNode;
}
```

# Doubly Linked List Summary

```jsx
class Node {
	constructor(val){
		this.val = val;
		this.next = null;
		this.prev = null;
	}
}

class DoublyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const newNode = new Node(val);
		if(!this.length){
			this.head = newNode;
			this.tail = newNode;
		} else{
			this.tail.next = newNode;
			newNode.prev = this.tail;
			this.tail = newNode;
		}
		this.length++;
		return this;
	}

	pop(){
		if(!this.head || !this.tail){
			return undefined;
		}
		const poppedNode = this.tail;
		if(this.length === 1){
			this.head = null;
			this.tail = null;
		} else{
			this.tail = poppedNode.prev;
			this.tail.next = null;
			//안하면 list에서는 연결이 끊겨도 pop한 노드에서의 연결이 남아있게 됨.
			poppedNode.prev = null;
		}
		this.length--;
		return poppedNode;
	}

	shift(){
		if(!this.length) return undefined;
		const oldHead = this.head;
	
		if(this.length === 1){
			this.head = null;
			this.tail = null;
		}else{
			this.head = oldHead.next;
			this.head.prev = null;
			oldHead.next = null;
		}
	
		this.length--;
		return oldHead;
	}

	unshift(val){
		const newNode = new Node(val);
		if(!this.length){
			this.head = newNode;
			this.tail = newNode;
		}else{
			this.head.prev = newNode;
			newNode.next = this.head;
			this.head = newNode;
		}
		this.length++;
		return this;
	}

	get(index){
		if(index < 0 || index >= this.length)return null;
		const count = 0;
		const current = this.head;
	
		if(index <= this.length/2){
			const count = 0;
			const current = this.head;		
			while(count != index){
				current = current.next;
				count++;
			}
		}else{
			const count = this.length - 1;
			const current = this.head;		
			while(count != index){
				current = current.prev;
				count--;
			}
		}
	
		return current;
	}
	
	set(index, val){
		const foundNode = this.get(index);
		if(foundNode !== null){
			foundNode.val = val;
			return true;
		}
		return false;
	}
	
	insert(index,val){
		if(index < 0 || index > this.length) return false;
		if(index === 0) return !!this.unshift(val);
		if(index === this.length) return !!this.push(val);
	
		const newNode = new Node(val);
		const beforeNode = this.get(index-1);
		const afterNode = beforeNode.next;
	
		beforeNode.next = newNode, newNode.prev = beforeNode;
		newNode.next = afterNode, afterNode.prev = newNode;
		this.length++;
		return true;
	}

	remove(index){
		if(index < 0 || index >= this.length) return undefined;	
		if(index === 0) return this.shift();
		if(index === this.length - 1) return this.pop();
	
		const removedNode = this.get(index);
		const beforeNode = removedNode.prev;
		const afterNode = removedNode.next;
	
		beforeNode.next = afterNode;
		afterNode.prev= beforeNode;
		removedNode.next = null;
		removedNode.prev = null;
		this.length--;
	
		return removedNode;
	}
}
```

## 이중연결리스트 BIG O

**Insertion**: O(1)

**Removal**: O(1)

단일 연결리스트의 경우 회문을 전체 돌아야하지만(O(N)) 이중연결리스트는 그럴 필요가 없음

`.prev` 속성이 있기 때문

**Searching**: O(N)

이론적으로 Searching은 O(N/2)이긴 한데 (인덱스에 따라 앞 뒤에서 시작 가능하므로)

결국 ,그래도 O(N)이랑 같음

**Access**: O(N)

## Recap

- 이중연결리스트는 prev빼고 단일연결리스트랑 거의 같음
- 노드를 찾을 때 단일 연결리스트에 비해 절반의 시간이 걸림
    - prev속성 덕에 인덱스의 위치를 통해 중간보다 길면 뒤에서시작이 가능하므로
- 그런데 prev 속성이 추가되므로 추가적인 메모리를 먹으니 염두해야 함



# Stack(스택)

후입선출(Last In Fisrt Out) 원칙따르는 데이터 모음

## 사용처

- 함수 호출을 다루는 상황 (콜스택)
- Undo/ Redo (가장 최근 액션을 없애야 하므로 ㅎㅅㅎ)
- Routing(history object)가 스택처럼 다뤄지기도 함(방문 페이지 기록 등..)
- 알고리즘

## 구성

- 배열도 됨

```jsx
const stack = [];
stack.push("google");
stack.push("instagram");
stack.push("youtube");
console.log(stack); //["google", "instagram", "youtube"];
stack.pop()//"youtube"
stack.push("amazon");
stack.pop()//"amazon"
/*
앞에서 다 다룰수도 있긴 함(개념적으로는 스택처럼 사용 가능)
이렇게 하면 인덱스를 다 밀어야해서(re-index) BIG O가 N임
push, pop은 BIG O가 O(1)가 됨 개꿀(인덱스 안건드려도 됨)
*/
stack.unshift("A");
stack.unshift("B");
stack.unshift("C");
console.log(stack); // ["C","B","A"];
stack.shift(); // "A"
```

- 링크드리스트도 됨
    - 기존 singly linked list의 pop메서드를 쓰면 앞에서부터 마지막으로 가기때문에 O(N)이 걸리므로 효율이 없음
    - 대신에 shift() , unshift()를 활용
        - 맨뒤에서 push, pop을 하는 대신 맨 앞에서 push, pop을 시키는 방식(이러면 상수시간 가능 :))

### push 수도코드

- 스택이 비어있는지 확인
    - 비어있으면 first, last 속성을 newNode로 설정
    - 하나라도 노드 있으면 변수만들어서 현재 Stack의 first를 변수에 저장
    - first속성을 새로만든 노드로 변경(newNode)
    - first의 next 속성을 변수에 저장한 노드로 할당
- 사이즈 올림
- 사이즈 반환

### pop 수도코드

- 스택에 노드가 있는지 없는 지확인
    - 비어있으면 null 출력
    - 안 비어있으면 first프로퍼티를  변수에 저장하고
    - 가장 마지막에 출력해줌
    - 노드가 하나뿐이면 first, last 둘다 null
    - 하나보다 많으면 first를 변수에 저장한 노드의 next로 바꿔줌
- 사이즈 하나 줄임
- 변수저장한 노드 반환

```jsx
class Node {
	constructor(value){
		this.value = value;
		this.next = null;
	}
}

class Stack {
	constructor(){
		this.first = null;
		this.last = null;
		this.size = 0;
	}

	push(val) {
		const newNode = new Node(val);
		if(!this.first){
				this.first = newNode;
				this.last = newNode;
		} else{
			const temp = this.first;
			this.first = newNode;
			this.first.next = temp;
			return ++this.isze;
		}
	}

	pop(){
		if(!this.first)return null;
		const temp = this.first;
		if(this.first === this.last){
			this.last = null;
		}
		this.first = this.first.next;
		this.size--;
		return temp,value;
	}
}
```

## BIG O of STACKS

삽입과 제거가 상수시간이 되는게 스택에서 젤 중요함

- Insertion - O(1)
- Removal - O(1)
- Searching - O(N)
- Access - O(N)

## Stack Recap

- LIFO
- 스택은 실행취소나 브라우저 기록 저장등에 사용됨
- JS에서는 지원안해줌 ㅋ
- 알고리즘에서는 그냥 배열 쓰는게편함


# (Queues)큐

선입선출(First In First Out) 원칙따르는 데이터 모음

## 사용처

- 줄서거나
- 프로그래밍에서는
    - 온라인접속 게임 대기
    - 컴퓨터 백그라운드 작업
    - 파일 업로드
    - 프린트 대기열

## 구성

배열로 해봄

```jsx
let q = [];
q.push("FIRST");
q.push("SECOND");
q.push("THIRD");
console.log(q);//["FIRST", "SECOND", "THIRD"];
q.shift(); //"FIRST" //이러면 리인덱싱 다해서 O(N)됨

q = [];
q.unshift("FIRST");
q.unshift("SECOND");
q.unshift("THIRD");
console.log(q);//["THIRD", "SECOND", "FIRST"];
q.pop() //"FIRST" //이렇게 하면 처음에 넣을떄(unshift) 리인덱싱 하므로 O(N)이 됨

```

클래스로 직접 만들어버리기

- 스택에서 봤던 단일 연결리스트의 문제처럼 pop을 사용하면 전체를 회문하여 tail을 찾아야하므로
- 큐를 구성할때 맨 뒤에 추가하고 맨 앞에서 제거하면 상수시간으로 만들 수 있게 됨.

```jsx
class Node{
	constructor(value){
		this.value = value;
		this.next = null;	
	}
}

class Queue {
	constructor(){
		this.first = null;
		this.last = null;
		this.size = 0;
	}

	enqueue(val){
		//리스트 가장 뒤에 추가
		const newNode = new Node(val);
		if(!this.first){
			this.first = newNode;
			this.last = newNode;
		}else{
			this.last.next = newNode;
			this.last = newNode;
		}
		return ++this.length;
	}

	dequeue(){
		//리스트 가장 앞을 제거
		if(!this.first) return null;
		const temp = this.first;
		if(this.first === this.last){
			this.last = null;
		}
		this.first = this.first.next;
		this.size--;
		return temp.value;
	}
}
```

### enqueue pseudo code

- 인자 받음
- 받은 인자로 새로운 노드 만듦
- 만약 큐가 비어있으면 해당 노드를 first, last 속성으로 정의
- 큐가 비 어있지 않다면 큐의 현재 last의 next를 새로운 노드로 변경
    - 새로운 노드를 큐의 last로 지정
- 길이 하나 추가하고 길이 리턴

### dequeue pseudo code

- 큐의 first속성이 비어있으면 null출력
- first속성을 변수에 저장
- first가 last와 같으면 (노드 하나면) first,last를 null로 설정
- 하나 이상의 노드가 있으면 큐의 first를 first.next의 노드로 설정
- 길이 하나 감소
- 그리고 제거한 노드의 값 반환

## BIG O of QUEUES

삽입과 제거가 상수시간이 되는게 큐에서 젤 중요함

스택과는 다르게 배열을 큐 용도로 사용하면 상수시간이 나오지 않는 것을 꼭 기억하자

- Insertion - O(1)
- Removal - O(1)
- Searching - O(N)
- Access - O(N)

## QUEUES Recap

- FIFO
- 큐는 줄서는 것 과 같음 맨앞에 선사람이 제일 먼저 나옴
- JS에서는 지원안해줌 ㅋ