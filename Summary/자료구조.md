# 단일 연결 리스트
배열의 인덱스와 다르게 링크드리스트는 기차 같이 걍 노드(값을 가진)가 연결되어 있음

- 헤드는 연결리스트의 시작 노드를 가리킴
- 테일은 연결리스트의 마지막 노드를 가리킴
- 헤드 노드가 어디있는지만 알고 있을 것이며 이 헤드 노드부터 다음 두번째 노드를 알아내며 계속하여 마지막 노드까지 접근하게 됨
- 탐색 용이를 위해 길이를 가지고 있게 됨

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/00bc7d6d-4691-414c-bfbd-63f581381882/Untitled.png)

| Lists | Array |
| --- | --- |
| 인덱스 없음 | 순서대로 인덱스 존재 |
| next포인터를 통해 다음 노드와 연결 | 삽입과 삭제의 비용이 많이 듦 |
| 랜덤한 접근 불가 | 특정 인덱스에 빠르게 접근 가능 |
|  |  |
- 링크드리스트는 삽입과 제거가 쉬움따라서 임의 접근이 필요하지 않은 아주 긴데이터 세트나 많은 정보에 대해 작업하는 경우 용이함.

## With Code

### Node

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

let frist = new Node("Hi");
first.next = new Node("there");
first.next.next = new Node("how");
first.next.next.next = new Node("are");
first.next.next.next.next = new Node("you");
/*
proto는 임의 삭제
console.log(first);
Node {
  val: 'Hi',
  next: Node {
    val: 'there',
    next: Node {
      val: 'how',
      next: Node {
        val: 'are',
        next: Node {
          val: 'you',
          next: null,
        }
      },
    }
  },
}
*/
```

### Singly Linked List

### Push 메서드

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

class SinglyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const node = new Node(val);
		if(!this.head){
//아무 것도 없으면 head와 tail모두 새로운 노드를 가리키게 됨
			this.head = node;
			this.tail = this.head;
		}else{
			//현재 노드("Hello")의 tail의
			// 다음을 새로 만든 노드("GoodBye")로 업데이트 하고
			this.tail.next = node;
			// 현재의 tail을 새로만든 노드("GoodBye")로 변경 해주면 됨
			this.tail = node;
			return this;
		}
	}
}

const list = new SinglyLinkedList()
list.push("Hello");
list.push("Good Bye");
console.log("HEAD!@@",list.head.next);
/*
'HEAD!@@' Node {
  val: 'Good Bye',
  next: Node {
    val: 99,
    next: null,
    ['__proto__']: { constructor: ƒ Node() }
  }
}
*/
```

### Push 메서드 pseudo code

- 값을 인자로 받음
- 받은 값으로 새로운 노드를 만듦
- 만약 리스트의 헤드프로퍼티가 없다면 헤드와 테일을 새로 생성한 노드로 변경한다
- 만약 리스트에 요소가 존재하면 현재 노드의 tail의 next를 새로만든 노드로 업데이트하고
- 현재의 테일을 새로만든 노드로 변경한다.
- 그리고 길이를 증가 시켜준다.
- 그리고 변경된 링크드리스트를 반환해준다.

### Pop메서드

배열처럼 마지막거를 그냥 빼면 되는게 아니라 마지막 노드를 추출한 다음 테일을 다시 가리키게 만드는 것이 어려워짐

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

class SinglyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const node = new Node(val);
		if(!this.head){
			this.head = node;
			this.tail = this.head;
		}else{
			this.tail.next = node;
			this.tail = node;
			return this;
		}
	}

	traverse(){
		let current = this.head;
		while(current){
			console.log(current.val);
			current = current.next;
		}
	}
}

const list = new SinglyLinkedList()
list.push("Hello");
list.push("Good Bye");
list.push("Good Morning");
list.traverse();
/*
'Hello'
'Good Bye'
'Good Morning'
*/
```

### Pop 메서드 pseudo code

- 인자 안받음
- 리스트에 노드가 없으면 undefined 리턴
- tail에 도달할때 까지 루핑 돔
- 리스트의 끝까지 따라가는 “temp”라고 하는 변수와 항상 한 노드이전것을 가리키는 “pre”라는 변수가 필요함
- temp라는 변수가 리스트의 끝에 이르렀을 때 이 pre변수가 마지막에서 두번 째 노드를 가리키게 됨.
- 길이하나 줄여줌
- 제거한 값 리턴