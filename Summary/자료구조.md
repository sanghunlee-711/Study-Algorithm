# 단일 연결 리스트
배열의 인덱스와 다르게 링크드리스트는 기차 같이 걍 노드(값을 가진)가 연결되어 있음

- 헤드는 연결리스트의 시작 노드를 가리킴
- 테일은 연결리스트의 마지막 노드를 가리킴
- 헤드 노드가 어디있는지만 알고 있을 것이며 이 헤드 노드부터 다음 두번째 노드를 알아내며 계속하여 마지막 노드까지 접근하게 됨
- 탐색 용이를 위해 길이를 가지고 있게 됨

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/00bc7d6d-4691-414c-bfbd-63f581381882/Untitled.png)

| Lists | Array |
| --- | --- |
| 인덱스 없음 | 순서대로 인덱스 존재 |
| next포인터를 통해 다음 노드와 연결 | 삽입과 삭제의 비용이 많이 듦 |
| 랜덤한 접근 불가 | 특정 인덱스에 빠르게 접근 가능 |
|  |  |
- 링크드리스트는 삽입과 제거가 쉬움따라서 임의 접근이 필요하지 않은 아주 긴데이터 세트나 많은 정보에 대해 작업하는 경우 용이함.

## With Code

### Node

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

let frist = new Node("Hi");
first.next = new Node("there");
first.next.next = new Node("how");
first.next.next.next = new Node("are");
first.next.next.next.next = new Node("you");
/*
proto는 임의 삭제
console.log(first);
Node {
  val: 'Hi',
  next: Node {
    val: 'there',
    next: Node {
      val: 'how',
      next: Node {
        val: 'are',
        next: Node {
          val: 'you',
          next: null,
        }
      },
    }
  },
}
*/
```

### Singly Linked List

### Push 메서드

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

class SinglyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const node = new Node(val);
		if(!this.head){
//아무 것도 없으면 head와 tail모두 새로운 노드를 가리키게 됨
			this.head = node;
			this.tail = this.head;
		}else{
			//현재 노드("Hello")의 tail의
			// 다음을 새로 만든 노드("GoodBye")로 업데이트 하고
			this.tail.next = node;
			// 현재의 tail을 새로만든 노드("GoodBye")로 변경 해주면 됨
			this.tail = node;
			return this;
		}
	}
}

const list = new SinglyLinkedList()
list.push("Hello");
list.push("Good Bye");
console.log("HEAD!@@",list.head.next);
/*
'HEAD!@@' Node {
  val: 'Good Bye',
  next: Node {
    val: 99,
    next: null,
    ['__proto__']: { constructor: ƒ Node() }
  }
}
*/
```

### Push 메서드 pseudo code

- 값을 인자로 받음
- 받은 값으로 새로운 노드를 만듦
- 만약 리스트의 헤드프로퍼티가 없다면 헤드와 테일을 새로 생성한 노드로 변경한다
- 만약 리스트에 요소가 존재하면 현재 노드의 tail의 next를 새로만든 노드로 업데이트하고
- 현재의 테일을 새로만든 노드로 변경한다.
- 그리고 길이를 증가 시켜준다.
- 그리고 변경된 링크드리스트를 반환해준다.

### Pop메서드

배열처럼 마지막거를 그냥 빼면 되는게 아니라 마지막 노드를 추출한 다음 테일을 다시 가리키게 만드는 것이 어려워짐

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

class SinglyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const node = new Node(val);
		if(!this.head){
			this.head = node;
			this.tail = this.head;
		}else{
			this.tail.next = node;
			this.tail = node;
			return this;
		}
	}

	traverse(){
		let current = this.head;
		while(current){
			console.log(current.val);
			current = current.next;
		}
	}

	pop(){
		if(!this.head) return undefined;
		let current = this.head;
		let newTail = current;
		//current의 next가 없을 때 까지 돌릴 거임
		while(current.next){
			//이렇게 하면 newTail이 계속 current보다
			// 하나 작은 곳에 위치하고 마지막에 되서는 
			//이동하지 않게 되므로 재 할당할 값이 남아 있을 수 있음
			newTail = current;
			current = current.next;
		}
		// tail을 새로운 테일로 매칭 시킴
		this.tail = newTail;
		this.tail.next = null;
		this.length--;
		if(this.length === 0){
		// 하나의 노드만 존재하는 경우 처리를 위함
			this.head = null;
			this.tail = null	
		}
		return current;
	}
}

const list = new SinglyLinkedList()
list.push("Hello");
list.push("Good Bye");
list.push("Good Morning");
list.traverse();
/*
'Hello'
'Good Bye'
'Good Morning'
*/
list.pop() //"Good Morning"값을 가진 노드
```

### Pop 메서드 pseudo code

- 인자 안받음
- 리스트에 노드가 없으면 undefined 리턴
- tail에 도달할때 까지 루핑 돔
- 리스트의 끝까지 따라가는 “temp”라고 하는 변수와 항상 한 노드이전것을 가리키는 “pre”라는 변수가 필요함
- temp라는 변수가 리스트의 끝에 이르렀을 때 이 pre변수가 마지막에서 두번 째 노드를 가리키게 됨.
- 길이하나 줄여줌
- 제거한 값 리턴

### Shift 메서드

제일 앞에 노드 제거 후 값 반환

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

class SinglyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const node = new Node(val);
		if(!this.head){
			this.head = node;
			this.tail = this.head;
		}else{
			this.tail.next = node;
			this.tail = node;
			return this;
		}
	}

	shift(){
		if(!this.head) return undefined;
		let removedHead = this.head;
		//Hello에서 GoodBye로 헤드를 옮김
		this.head = removedHead.next;
		this.lenth--;
		if(this.length === 0){
		//마지막 노드를 제거하고 난 뒤 tail이 노드를 가지고 있게 되는 것을 처리하기 위함.
			this.head = null;
			this.tail = null	
		}
		return removedHead;
	}
}

const list = new SinglyLinkedList()
list.push("Hello");
list.push("Good Bye");
list.push("Good Morning");
list.shift(); // {val: "Hello", next: Node}

```

### Shift 메서드 pseudo code

- 노드가 없으면 return undefined;
- 노드가 존재할 경우 현재의 헤드 속성을 변수에 저장하고
- 헤드 속성을 업데이트 한 다음 한칸 이동시킴
- 길이 하나 줄임
- 제거한 노드 반환

### Unshift 메서드

링크드리스트 제일 앞에 새로운 노드 추가

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

class SinglyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const node = new Node(val);
		if(!this.head){
			this.head = node;
			this.tail = this.head;
		}else{
			this.tail.next = node;
			this.tail = node;
			return this;
		}
	}

	unshift(val){
		const newNode = new Node(val);
		if(!this.head){
			this.head = newNode;
			this.tail = this.head;
		}else{
		//else가 없으면 마지막 노드가 자신을 가리키게 되는 아찔한 상황 발생
			newNode.next = this.head;
			this.head = newNode;
		}
		this.length++;
		return this;
	}
}

const list = new SinglyLinkedList()
list.push("Hello");
list.push("Good Bye");
list.push("Good Morning");
list.unshift("Cheers");
```

### Unshift 메서드 pseudo code

- 인자로 값을 받음
- 새로운 노드를 만듦
- 헤드가 없는 경우 헤드와 테일 모두가 새로운 노드를 가리키게함
- 노드가 이미 있는 경우 새롭게 생성된 노드의 next를 현재의 헤드값으로 설정하고 헤드가 새롭게 생성된 노드를 가리키도록 한 다음
- 길이를 1증가시킴
- 변화된 링크들 리스트를 반환


### get 메서드

인덱스나 포지션을 받아서 주어진 위치에 있는 노드를 반환하는 메서드이다.

- 0을 주면 헤드를 4를 주면 다섯번째 노드를 반환 등..

중요한 점은 주어진 숫자 만큼 리스트에서 헤드를 시작으로 계속 따라간 후 해당위치의 노드를 반환한다는 것.

그러므로 항상 위치를 기준으로 무엇인가에 접근해야하는 경우 어레이를 사용하는 것이 좋을 수 있음.

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

class SinglyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const node = new Node(val);
		if(!this.head){
			this.head = node;
			this.tail = this.head;
		}else{
			this.tail.next = node;
			this.tail = node;
			return this;
		}
		this.length++;
	}

  get(index){
    if(index < 0 || index >= this.length) return null;
    let counter = 0;
    let current = this.head;
    while(counter !== index) {
      current = current.next;
      counter++;
    }
    return current;
    
  }
}

const list = new SinglyLinkedList()
list.push("Hello");
list.push("Good Bye");
list.push("Good Morning");
list.push("<3");
list.push(":)");

const toBeNull = list.get(-3);
const toBeEmoji = list.get(3);
console.log("@@",toBeNull, toBeEmoji.val);
```

### get 메서드 pseudo code

- 인덱스를 인자로 받아야 함.
- 만약 인덱스가 0보다 작거나 길이보다 크거나 같은 경우 return null
- 루프를 통해 인덱스에 접근하여 특정 인덱스의 노드를 반환해 줌

### set 메서드

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

class SinglyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const node = new Node(val);
    this.length++;
		if(!this.head){
			this.head = node;
			this.tail = this.head;
		}else{
			this.tail.next = node;
			this.tail = node;
			return this;
		}
	}

  get(index){
    if(index < 0 || index >= this.length) return null;
    let counter = 0;
    let current = this.head;
    while(counter !== index) {
      current = current.next;
      counter++;
    }
    return current;
  }

	set(index, val){
		const foundNode = this.get(index);
		if(foundNode) {
			foundNode.val = val;
			return true;
		}
		return false;
	}
}

const list = new SinglyLinkedList()
list.push("Hello");
list.push("Good Bye");
list.push("Good Morning");
list.push("<3");
list.push(":)");

const toBeNull = list.get(-3);
const toBeEmoji = list.get(3);
console.log("@@",toBeNull, toBeEmoji.val);
```

### set 메서드 pseudo code

- 인덱스와 값을 인자로 받음
- get 메서드를 이용해서 특정 node를 찾음
- 특정 Node가 없으면 return false
- 노드가 있으면 인자로 받은 값을 통해 해당 위치 index의 노드 값을 변경해주고 return true

 

### Insert 메서드

주어진 노드를 주어진 위치에 넣어줌

```jsx
class Node {
		constructor(val){
		this.val = val;
		this.next = null;
	}
}

class SinglyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const node = new Node(val);
    this.length++;
		if(!this.head){
			this.head = node;
			this.tail = this.head;
		}else{
			this.tail.next = node;
			this.tail = node;
			return this;
		}
	}

  
	pop(){
		if(!this.head) return undefined;
		let current = this.head;
		let newTail = current;
		
		while(current.next){
			newTail = current;
			current = current.next;
		}

		this.tail = newTail;
		this.tail.next = null;
		this.length--;
		if(this.length === 0){
			this.head = null;
			this.tail = null	
		}
		return current;
	}
  
	unshift(val){
		const newNode = new Node(val);
		if(!this.head){
			this.head = newNode;
			this.tail = this.head;
		}else{
			newNode.next = this.head;
			this.head = newNode;
		}
		this.length++;
		return this;
	}
  
	shift(){
		if(!this.head) return undefined;
		let removedHead = this.head;
		this.head = removedHead.next;
		this.lenth--;
		if(this.length === 0){
			this.head = null;
			this.tail = null	
		}
		return removedHead;
	}

  get(index){
    if(index < 0 || index >= this.length) return null;
    let counter = 0;
    let current = this.head;
    while(counter !== index) {
      current = current.next;
      counter++;
    }
    return current;
  }
  
  set(index, val) {
    const foundNode = this.get(index);
    if(foundNode){
      foundNode.val = val;
      return true
    }
    return false;
  }
  
  insert(index, val) {
    if(index < 0 || index> this.length) return false;
    if(index === this.length) return !!this.push(val);
    if(index === 0) return !!this.unshift(val);

    const newNode = new Node(val);
    const previous = this.get(index - 1);
    const temp = previous.next;
    previous.next = newNode;
    newNode.next = temp;
    this.length++;
    return true;
  }
}

const list = new SinglyLinkedList()
list.push("Hello");
list.push("Good Bye");
list.push("Good Morning");
list.push("<3");
list.insert(0,"FIRST");
list.insert(5,"LAST");
console.clear();
console.log("true",list.insert(6,"TRUE"));
console.log("false",list.insert(100,"FALSE"));
```

### Insert 메서드 pseudo code

- 범위를 벗어난 경우 삽입 불가이므로 인덱스가 0 보다 작거나 리스트의 길이보다 큰 경우 false반환
- 인덱스가 길이와 같으면 push메서드 활용하면 됨
- index가 0 이면 unshift메서드 활용하면 됨
- 이제 get메서드를 활용해서 인덱스를 받아오고 그 index의 하나 전 노드(index-1)에 접근하면 됨
- 그 접근한 노드에 next속성을  새로운노드로 업데이트 하고
- 그리고 새로운 노드의 next속성을 인덱스로 받아온 노드에 연결하면 됨
- 길이 올림
- return true(실패하면 false)

PS: !!는 불리안 연산자로 true로 판단되면 true, false로 판단되면 false를 리턴해줌(Boolean()이랑 비슷)


### Remove 메서드

특정 포지션의 노드를 지워줌

```jsx
remove(index){
	if(index < 0 || index > this.length) return undefined;
	if(index === 0) return this.shift();
	if(index === this.length - 1) return this.pop();
	const previousNode = this.get(index-1);
	const removed = previousNode.next;
	previousNode.next = removed.next;
	this.length--;
	return removed;
}
```

### Remove 메서드 pseudo code

- 인덱스 값이 0 보다 작거나 리스트 길이 보다 큰 경우 return undefined
- 만약 인덱스가 길이-1과 같으면 pop
- 인덱스가 0 이면 shift메서드 사용
- 그렇지 않다면 get 메서드를 사용해서 index -1의 노드로 접근
- 접근한 노드의 next를 next.next노드로 바꿔줌
- 길이하나 줄임
- 제거 된 노드값을 반환

### Reverse 메서드

특정 포지션의 노드를 지워줌

```jsx
reverse(){
	let node = this.head;
	this.head = this.tail;
	this.tail = node;
	let prev = null, next = null;

	for(let i = 0; i < this.length; i++) {
		next = node.next;
		node.next = prev;
		prev = node;
		node = next;		
	}
	return this;
}
print() {
	let arr = [];
	let current = this.head;
	while(current){
		arr.push(current.val);
	}
	return arr;
}

```

### Reverse 메서드 pseudo code

- 헤드와 테일을 바꾼다
- next, ,current(head로 initializing) ,prev라는 변수를 만듦
- 리스트 루프 돌면서 current의 next를  next 변수로 설정
- current의 next를 이전에 바로 앞에있던 노드를 가리키도록 설정
- current의 node값을 prev에 저장하고 current의 next속성을 prev로 만들어줌

### 빅오 복잡도

- Insertion: O(1)
- Removal: O(1)[제일 앞인경우] or O(N)[pop인 경우 전체리스트를 따라가야 하므로]
- Searching: O(N)
- Access: O(N)

→ 정리하자면 단방향 연결리스트가 삽입과삭제의 경우 배열에 비해 유리

임의 접근이 없거나 주어진 순서대로 데이터 관리 또는 순서대로 데이터에 접근한다면 단방향 연결리스트가 유리

# Doubly Linked List(이중 연결 리스트)

- 거의 Singly Linked와 유사함
- 배열과 유사하나 다름
- 테일 헤드 있음
- 모든 노드가 next, previous attributes가 있음.
- 유연성이 더 있는 만큼 메모리가 많이 듦(next+previous를 저장해야 함으로)

## 기본 구조 만들기

```jsx
class Node {
	constructor(val){
		this.val = val;
		this.next = null;
		this.prev = null;
	}
}

class DoublyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}
}
```

## Push

노드나 값을 이중연결리스트에 추가

```jsx
push(val){
	const newNode = new Node(val);
	if(!this.length){
		this.head = newNode;
		this.tail = newNode;
	} else{
		this.tail.next = newNode;
		newNode.prev = this.tail;
		this.tail = newNode;
	}
	this.length++;
	return this;
}
```

## Push pseudocode

- 값을 가지는 새로운 노드 만들기
- 헤드가 null인지 아니면 길이가 0 인지 확인(리스트가 비어있는지)
    - 비어 있으면 head,tail이 모두 새로운 노드로 설정
    - 비어 있지 않다면 현재 양방향 리스트의 테일의 next 속성에 새로운 노드를 추가
    - 그리고 새로운 노드의 prev속성에 테일을 추가
- 길이를 1 올려줌
- 변경된 Doubly Linked List를 반환

# Doubly Linked List Summary

```jsx
class Node {
	constructor(val){
		this.val = val;
		this.next = null;
		this.prev = null;
	}
}

class DoublyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const newNode = new Node(val);
		if(!this.length){
			this.head = newNode;
			this.tail = newNode;
		} else{
			this.tail.next = newNode;
			newNode.prev = this.tail;
			this.tail = newNode;
		}
		this.length++;
		return this;
	}
}
```