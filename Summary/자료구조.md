# ë‹¨ì¼ ì—°ê²° ë¦¬ìŠ¤íŠ¸
ë°°ì—´ì˜ ì¸ë±ìŠ¤ì™€ ë‹¤ë¥´ê²Œ ë§í¬ë“œë¦¬ìŠ¤íŠ¸ëŠ” ê¸°ì°¨ ê°™ì´ ê± ë…¸ë“œ(ê°’ì„ ê°€ì§„)ê°€ ì—°ê²°ë˜ì–´ ìˆìŒ

- í—¤ë“œëŠ” ì—°ê²°ë¦¬ìŠ¤íŠ¸ì˜ ì‹œì‘ ë…¸ë“œë¥¼ ê°€ë¦¬í‚´
- í…Œì¼ì€ ì—°ê²°ë¦¬ìŠ¤íŠ¸ì˜ ë§ˆì§€ë§‰ ë…¸ë“œë¥¼ ê°€ë¦¬í‚´
- í—¤ë“œ ë…¸ë“œê°€ ì–´ë””ìˆëŠ”ì§€ë§Œ ì•Œê³  ìˆì„ ê²ƒì´ë©° ì´ í—¤ë“œ ë…¸ë“œë¶€í„° ë‹¤ìŒ ë‘ë²ˆì§¸ ë…¸ë“œë¥¼ ì•Œì•„ë‚´ë©° ê³„ì†í•˜ì—¬ ë§ˆì§€ë§‰ ë…¸ë“œê¹Œì§€ ì ‘ê·¼í•˜ê²Œ ë¨
- íƒìƒ‰ ìš©ì´ë¥¼ ìœ„í•´ ê¸¸ì´ë¥¼ ê°€ì§€ê³  ìˆê²Œ ë¨



| Lists | Array |
| --- | --- |
| ì¸ë±ìŠ¤ ì—†ìŒ | ìˆœì„œëŒ€ë¡œ ì¸ë±ìŠ¤ ì¡´ì¬ |
| nextí¬ì¸í„°ë¥¼ í†µí•´ ë‹¤ìŒ ë…¸ë“œì™€ ì—°ê²° | ì‚½ì…ê³¼ ì‚­ì œì˜ ë¹„ìš©ì´ ë§ì´ ë“¦ |
| ëœë¤í•œ ì ‘ê·¼ ë¶ˆê°€ | íŠ¹ì • ì¸ë±ìŠ¤ì— ë¹ ë¥´ê²Œ ì ‘ê·¼ ê°€ëŠ¥ |


- ë§í¬ë“œë¦¬ìŠ¤íŠ¸ëŠ” ì‚½ì…ê³¼ ì œê±°ê°€ ì‰¬ì›€ë”°ë¼ì„œ ì„ì˜ ì ‘ê·¼ì´ í•„ìš”í•˜ì§€ ì•Šì€ ì•„ì£¼ ê¸´ë°ì´í„° ì„¸íŠ¸ë‚˜ ë§ì€ ì •ë³´ì— ëŒ€í•´ ì‘ì—…í•˜ëŠ” ê²½ìš° ìš©ì´í•¨.



## Node

```jsx
class Node {
 constructor(val){
  this.val = val;
  this.next = null;
 }
}

let frist = new Node("Hi");
first.next = new Node("there");
first.next.next = new Node("how");
first.next.next.next = new Node("are");
first.next.next.next.next = new Node("you");

```



## Push ë©”ì„œë“œ


## Push ë©”ì„œë“œ pseudo code

- ê°’ì„ ì¸ìë¡œ ë°›ìŒ
- ë°›ì€ ê°’ìœ¼ë¡œ ìƒˆë¡œìš´ ë…¸ë“œë¥¼ ë§Œë“¦
- ë§Œì•½ ë¦¬ìŠ¤íŠ¸ì˜ í—¤ë“œí”„ë¡œí¼í‹°ê°€ ì—†ë‹¤ë©´ í—¤ë“œì™€ í…Œì¼ì„ ìƒˆë¡œ ìƒì„±í•œ ë…¸ë“œë¡œ ë³€ê²½í•œë‹¤
- ë§Œì•½ ë¦¬ìŠ¤íŠ¸ì— ìš”ì†Œê°€ ì¡´ì¬í•˜ë©´ í˜„ì¬ ë…¸ë“œì˜ tailì˜ nextë¥¼ ìƒˆë¡œë§Œë“  ë…¸ë“œë¡œ ì—…ë°ì´íŠ¸í•˜ê³ 
- í˜„ì¬ì˜ í…Œì¼ì„ ìƒˆë¡œë§Œë“  ë…¸ë“œë¡œ ë³€ê²½í•œë‹¤.
- ê·¸ë¦¬ê³  ê¸¸ì´ë¥¼ ì¦ê°€ ì‹œì¼œì¤€ë‹¤.
- ê·¸ë¦¬ê³  ë³€ê²½ëœ ë§í¬ë“œë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•´ì¤€ë‹¤.


```javascript



push(val){
	const node = new Node(val);
	if(!this.head){
//ì•„ë¬´ ê²ƒë„ ì—†ìœ¼ë©´ headì™€ tailëª¨ë‘ ìƒˆë¡œìš´ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ê²Œ ë¨
		this.head = node;
		this.tail = this.head;
	}else{
		//í˜„ì¬ ë…¸ë“œ("Hello")ì˜ tailì˜
		// ë‹¤ìŒì„ ìƒˆë¡œ ë§Œë“  ë…¸ë“œ("GoodBye")ë¡œ ì—…ë°ì´íŠ¸ í•˜ê³ 
		this.tail.next = node;
		// í˜„ì¬ì˜ tailì„ ìƒˆë¡œë§Œë“  ë…¸ë“œ("GoodBye")ë¡œ ë³€ê²½ í•´ì£¼ë©´ ë¨
		this.tail = node;
		return this;
	}
}



```

## Popë©”ì„œë“œ

ë°°ì—´ì²˜ëŸ¼ ë§ˆì§€ë§‰ê±°ë¥¼ ê·¸ëƒ¥ ë¹¼ë©´ ë˜ëŠ”ê²Œ ì•„ë‹ˆë¼ ë§ˆì§€ë§‰ ë…¸ë“œë¥¼ ì¶”ì¶œí•œ ë‹¤ìŒ í…Œì¼ì„ ë‹¤ì‹œ ê°€ë¦¬í‚¤ê²Œ ë§Œë“œëŠ” ê²ƒì´ ì–´ë ¤ì›Œì§

## Pop ë©”ì„œë“œ pseudo code

- ì¸ì ì•ˆë°›ìŒ
- ë¦¬ìŠ¤íŠ¸ì— ë…¸ë“œê°€ ì—†ìœ¼ë©´ undefined ë¦¬í„´
- tailì— ë„ë‹¬í• ë•Œ ê¹Œì§€ ë£¨í•‘ ë”
- ë¦¬ìŠ¤íŠ¸ì˜ ëê¹Œì§€ ë”°ë¼ê°€ëŠ” â€œtempâ€ë¼ê³  í•˜ëŠ” ë³€ìˆ˜ì™€ í•­ìƒ í•œ ë…¸ë“œì´ì „ê²ƒì„ ê°€ë¦¬í‚¤ëŠ” â€œpreâ€ë¼ëŠ” ë³€ìˆ˜ê°€ í•„ìš”í•¨
- tempë¼ëŠ” ë³€ìˆ˜ê°€ ë¦¬ìŠ¤íŠ¸ì˜ ëì— ì´ë¥´ë €ì„ ë•Œ ì´ preë³€ìˆ˜ê°€ ë§ˆì§€ë§‰ì—ì„œ ë‘ë²ˆ ì§¸ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ê²Œ ë¨.
- ê¸¸ì´í•˜ë‚˜ ì¤„ì—¬ì¤Œ
- ì œê±°í•œ ê°’ ë¦¬í„´

```javascript



	



	traverse(){
		let current = this.head;
		while(current){
			console.log(current.val);
			current = current.next;
		}
	}

	pop(){
		if(!this.head) return undefined;
		let current = this.head;
		let newTail = current;
		//currentì˜ nextê°€ ì—†ì„ ë•Œ ê¹Œì§€ ëŒë¦´ ê±°ì„
		while(current.next){
			//ì´ë ‡ê²Œ í•˜ë©´ newTailì´ ê³„ì† currentë³´ë‹¤
			// í•˜ë‚˜ ì‘ì€ ê³³ì— ìœ„ì¹˜í•˜ê³  ë§ˆì§€ë§‰ì— ë˜ì„œëŠ” 
			//ì´ë™í•˜ì§€ ì•Šê²Œ ë˜ë¯€ë¡œ ì¬ í• ë‹¹í•  ê°’ì´ ë‚¨ì•„ ìˆì„ ìˆ˜ ìˆìŒ
			newTail = current;
			current = current.next;
		}
		// tailì„ ìƒˆë¡œìš´ í…Œì¼ë¡œ ë§¤ì¹­ ì‹œí‚´
		this.tail = newTail;
		this.tail.next = null;
		this.length--;
		if(this.length === 0){
		// í•˜ë‚˜ì˜ ë…¸ë“œë§Œ ì¡´ì¬í•˜ëŠ” ê²½ìš° ì²˜ë¦¬ë¥¼ ìœ„í•¨
			this.head = null;
			this.tail = null	
		}
		return current;
	}



```



## Shift ë©”ì„œë“œ

ì œì¼ ì•ì— ë…¸ë“œ ì œê±° í›„ ê°’ ë°˜í™˜

## Shift ë©”ì„œë“œ pseudo code

- ë…¸ë“œê°€ ì—†ìœ¼ë©´ return undefined;
- ë…¸ë“œê°€ ì¡´ì¬í•  ê²½ìš° í˜„ì¬ì˜ í—¤ë“œ ì†ì„±ì„ ë³€ìˆ˜ì— ì €ì¥í•˜ê³ 
- í—¤ë“œ ì†ì„±ì„ ì—…ë°ì´íŠ¸ í•œ ë‹¤ìŒ í•œì¹¸ ì´ë™ì‹œí‚´
- ê¸¸ì´ í•˜ë‚˜ ì¤„ì„
- ì œê±°í•œ ë…¸ë“œ ë°˜í™˜


```javascript



	



shift(){
	if(!this.head) return undefined;
	let removedHead = this.head;
	//Helloì—ì„œ GoodByeë¡œ í—¤ë“œë¥¼ ì˜®ê¹€
	this.head = removedHead.next;
	this.lenth--;
	if(this.length === 0){
	//ë§ˆì§€ë§‰ ë…¸ë“œë¥¼ ì œê±°í•˜ê³  ë‚œ ë’¤ tailì´ ë…¸ë“œë¥¼ ê°€ì§€ê³  ìˆê²Œ ë˜ëŠ” ê²ƒì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•¨.
		this.head = null;
		this.tail = null	
	}
	return removedHead;
}



```


## Unshift ë©”ì„œë“œ

ë§í¬ë“œë¦¬ìŠ¤íŠ¸ ì œì¼ ì•ì— ìƒˆë¡œìš´ ë…¸ë“œ ì¶”ê°€


## Unshift ë©”ì„œë“œ pseudo code

- ì¸ìë¡œ ê°’ì„ ë°›ìŒ
- ìƒˆë¡œìš´ ë…¸ë“œë¥¼ ë§Œë“¦
- í—¤ë“œê°€ ì—†ëŠ” ê²½ìš° í—¤ë“œì™€ í…Œì¼ ëª¨ë‘ê°€ ìƒˆë¡œìš´ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ê²Œí•¨
- ë…¸ë“œê°€ ì´ë¯¸ ìˆëŠ” ê²½ìš° ìƒˆë¡­ê²Œ ìƒì„±ëœ ë…¸ë“œì˜ nextë¥¼ í˜„ì¬ì˜ í—¤ë“œê°’ìœ¼ë¡œ ì„¤ì •í•˜ê³  í—¤ë“œê°€ ìƒˆë¡­ê²Œ ìƒì„±ëœ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ë„ë¡ í•œ ë‹¤ìŒ
- ê¸¸ì´ë¥¼ 1ì¦ê°€ì‹œí‚´
- ë³€í™”ëœ ë§í¬ë“¤ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜

```javascript
unshift(val){
	const newNode = new Node(val);
	if(!this.head){
		this.head = newNode;
		this.tail = this.head;
	}else{
	//elseê°€ ì—†ìœ¼ë©´ ë§ˆì§€ë§‰ ë…¸ë“œê°€ ìì‹ ì„ ê°€ë¦¬í‚¤ê²Œ ë˜ëŠ” ì•„ì°”í•œ ìƒí™© ë°œìƒ
		newNode.next = this.head;
		this.head = newNode;
	}
	this.length++;
	return this;
}

```



## Get ë©”ì„œë“œ

ì¸ë±ìŠ¤ë‚˜ í¬ì§€ì…˜ì„ ë°›ì•„ì„œ ì£¼ì–´ì§„ ìœ„ì¹˜ì— ìˆëŠ” ë…¸ë“œë¥¼ ë°˜í™˜í•˜ëŠ” ë©”ì„œë“œì´ë‹¤.

- 0ì„ ì£¼ë©´ í—¤ë“œë¥¼ 4ë¥¼ ì£¼ë©´ ë‹¤ì„¯ë²ˆì§¸ ë…¸ë“œë¥¼ ë°˜í™˜ ë“±..

ì¤‘ìš”í•œ ì ì€ ì£¼ì–´ì§„ ìˆ«ì ë§Œí¼ ë¦¬ìŠ¤íŠ¸ì—ì„œ í—¤ë“œë¥¼ ì‹œì‘ìœ¼ë¡œ ê³„ì† ë”°ë¼ê°„ í›„ í•´ë‹¹ìœ„ì¹˜ì˜ ë…¸ë“œë¥¼ ë°˜í™˜í•œë‹¤ëŠ” ê²ƒ.

ê·¸ëŸ¬ë¯€ë¡œ í•­ìƒ ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë¬´ì—‡ì¸ê°€ì— ì ‘ê·¼í•´ì•¼í•˜ëŠ” ê²½ìš° ì–´ë ˆì´ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ì„ ìˆ˜ ìˆìŒ.

## Get ë©”ì„œë“œ pseudo code

- ì¸ë±ìŠ¤ë¥¼ ì¸ìë¡œ ë°›ì•„ì•¼ í•¨.
- ë§Œì•½ ì¸ë±ìŠ¤ê°€ 0ë³´ë‹¤ ì‘ê±°ë‚˜ ê¸¸ì´ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ì€ ê²½ìš° return null
- ë£¨í”„ë¥¼ í†µí•´ ì¸ë±ìŠ¤ì— ì ‘ê·¼í•˜ì—¬ íŠ¹ì • ì¸ë±ìŠ¤ì˜ ë…¸ë“œë¥¼ ë°˜í™˜í•´ ì¤Œ

```jsx
  get(index){
    if(index < 0 || index >= this.length) return null;
    let counter = 0;
    let current = this.head;
    while(counter !== index) {
      current = current.next;
      counter++;
    }
    return current;
    
  }
```



## Set ë©”ì„œë“œ
íŠ¹ì • ì¸ë±ìŠ¤ì˜ ë…¸ë“œ ê°’ì„ ë³€ê²½

## Set ë©”ì„œë“œ pseudo code

- ì¸ë±ìŠ¤ì™€ ê°’ì„ ì¸ìë¡œ ë°›ìŒ
- get ë©”ì„œë“œë¥¼ ì´ìš©í•´ì„œ íŠ¹ì • nodeë¥¼ ì°¾ìŒ
- íŠ¹ì • Nodeê°€ ì—†ìœ¼ë©´ return false
- ë…¸ë“œê°€ ìˆìœ¼ë©´ ì¸ìë¡œ ë°›ì€ ê°’ì„ í†µí•´ í•´ë‹¹ ìœ„ì¹˜ indexì˜ ë…¸ë“œ ê°’ì„ ë³€ê²½í•´ì£¼ê³  return true

```jsx
	set(index, val){
		const foundNode = this.get(index);
		if(foundNode) {
			foundNode.val = val;
			return true;
		}
		return false;
	}
```



 

## Insert ë©”ì„œë“œ

ì£¼ì–´ì§„ ë…¸ë“œë¥¼ ì£¼ì–´ì§„ ìœ„ì¹˜ì— ë„£ì–´ì¤Œ

## Insert ë©”ì„œë“œ pseudo code

- ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ ê²½ìš° ì‚½ì… ë¶ˆê°€ì´ë¯€ë¡œ ì¸ë±ìŠ¤ê°€ 0 ë³´ë‹¤ ì‘ê±°ë‚˜ ë¦¬ìŠ¤íŠ¸ì˜ ê¸¸ì´ë³´ë‹¤ í° ê²½ìš° falseë°˜í™˜
- ì¸ë±ìŠ¤ê°€ ê¸¸ì´ì™€ ê°™ìœ¼ë©´ pushë©”ì„œë“œ í™œìš©í•˜ë©´ ë¨
- indexê°€ 0 ì´ë©´ unshiftë©”ì„œë“œ í™œìš©í•˜ë©´ ë¨
- ì´ì œ getë©”ì„œë“œë¥¼ í™œìš©í•´ì„œ ì¸ë±ìŠ¤ë¥¼ ë°›ì•„ì˜¤ê³  ê·¸ indexì˜ í•˜ë‚˜ ì „ ë…¸ë“œ(index-1)ì— ì ‘ê·¼í•˜ë©´ ë¨
- ê·¸ ì ‘ê·¼í•œ ë…¸ë“œì— nextì†ì„±ì„  ìƒˆë¡œìš´ë…¸ë“œë¡œ ì—…ë°ì´íŠ¸ í•˜ê³ 
- ê·¸ë¦¬ê³  ìƒˆë¡œìš´ ë…¸ë“œì˜ nextì†ì„±ì„ ì¸ë±ìŠ¤ë¡œ ë°›ì•„ì˜¨ ë…¸ë“œì— ì—°ê²°í•˜ë©´ ë¨
- ê¸¸ì´ ì˜¬ë¦¼
- return true(ì‹¤íŒ¨í•˜ë©´ false)

PS: !!ëŠ” ë¶ˆë¦¬ì•ˆ ì—°ì‚°ìë¡œ trueë¡œ íŒë‹¨ë˜ë©´ true, falseë¡œ íŒë‹¨ë˜ë©´ falseë¥¼ ë¦¬í„´í•´ì¤Œ(Boolean()ì´ë‘ ë¹„ìŠ·)


```javascript
insert(index, val) {
	if(index < 0 || index> this.length) return false;
	if(index === this.length) return !!this.push(val);
	if(index === 0) return !!this.unshift(val);

	const newNode = new Node(val);
	const previous = this.get(index - 1);
	const temp = previous.next;
	previous.next = newNode;
	newNode.next = temp;
	this.length++;
	return true;
}
```



## Remove ë©”ì„œë“œ

íŠ¹ì • í¬ì§€ì…˜ì˜ ë…¸ë“œë¥¼ ì§€ì›Œì¤Œ

## Remove ë©”ì„œë“œ pseudo code

- ì¸ë±ìŠ¤ ê°’ì´ 0 ë³´ë‹¤ ì‘ê±°ë‚˜ ë¦¬ìŠ¤íŠ¸ ê¸¸ì´ ë³´ë‹¤ í° ê²½ìš° return undefined
- ë§Œì•½ ì¸ë±ìŠ¤ê°€ ê¸¸ì´-1ê³¼ ê°™ìœ¼ë©´ pop
- ì¸ë±ìŠ¤ê°€ 0 ì´ë©´ shiftë©”ì„œë“œ ì‚¬ìš©
- ê·¸ë ‡ì§€ ì•Šë‹¤ë©´ get ë©”ì„œë“œë¥¼ ì‚¬ìš©í•´ì„œ index -1ì˜ ë…¸ë“œë¡œ ì ‘ê·¼
- ì ‘ê·¼í•œ ë…¸ë“œì˜ nextë¥¼ next.nextë…¸ë“œë¡œ ë°”ê¿”ì¤Œ
- ê¸¸ì´í•˜ë‚˜ ì¤„ì„
- ì œê±° ëœ ë…¸ë“œê°’ì„ ë°˜í™˜

```jsx
remove(index){
	if(index < 0 || index > this.length) return undefined;
	if(index === 0) return this.shift();
	if(index === this.length - 1) return this.pop();
	const previousNode = this.get(index-1);
	const removed = previousNode.next;
	previousNode.next = removed.next;
	this.length--;
	return removed;
}
```



## Reverse ë©”ì„œë“œ

ë¦¬ìŠ¤íŠ¸ ì „ì²´ë¥¼ ë’¤ì§‘ì–´ ì¤Œ

## Reverse ë©”ì„œë“œ pseudo code

- í—¤ë“œì™€ í…Œì¼ì„ ë°”ê¾¼ë‹¤
- next, ,current(headë¡œ initializing) ,prevë¼ëŠ” ë³€ìˆ˜ë¥¼ ë§Œë“¦
- ë¦¬ìŠ¤íŠ¸ ë£¨í”„ ëŒë©´ì„œ currentì˜ nextë¥¼  next ë³€ìˆ˜ë¡œ ì„¤ì •
- currentì˜ nextë¥¼ ì´ì „ì— ë°”ë¡œ ì•ì—ìˆë˜ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ë„ë¡ ì„¤ì •
- currentì˜ nodeê°’ì„ prevì— ì €ì¥í•˜ê³  currentì˜ nextì†ì„±ì„ prevë¡œ ë§Œë“¤ì–´ì¤Œ

```jsx
reverse(){
	let node = this.head;
	this.head = this.tail;
	this.tail = node;
	let prev = null, next = null;

	for(let i = 0; i < this.length; i++) {
		next = node.next;
		node.next = prev;
		prev = node;
		node = next;		
	}
	return this;
}
print() {
	let arr = [];
	let current = this.head;
	while(current){
		arr.push(current.val);
	}
	return arr;
}

```



## ë‹¨ì¼ì—°ê²°ë¦¬ìŠ¤íŠ¸ ë¹…ì˜¤ ë³µì¡ë„(Big O of Singly Linked List )

- Insertion: O(1)
- Removal: O(1)[ì œì¼ ì•ì¸ê²½ìš°] or O(N)[popì¸ ê²½ìš° ì „ì²´ë¦¬ìŠ¤íŠ¸ë¥¼ ë”°ë¼ê°€ì•¼ í•˜ë¯€ë¡œ]
- Searching: O(N)
- Access: O(N)

â†’ ì •ë¦¬í•˜ìë©´ ë‹¨ë°©í–¥ ì—°ê²°ë¦¬ìŠ¤íŠ¸ê°€ ì‚½ì…ê³¼ì‚­ì œì˜ ê²½ìš° ë°°ì—´ì— ë¹„í•´ ìœ ë¦¬

ì„ì˜ ì ‘ê·¼ì´ ì—†ê±°ë‚˜ ì£¼ì–´ì§„ ìˆœì„œëŒ€ë¡œ ë°ì´í„° ê´€ë¦¬ ë˜ëŠ” ìˆœì„œëŒ€ë¡œ ë°ì´í„°ì— ì ‘ê·¼í•œë‹¤ë©´ ë‹¨ë°©í–¥ ì—°ê²°ë¦¬ìŠ¤íŠ¸ê°€ ìœ ë¦¬

# Doubly Linked List(ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸)

- ê±°ì˜ Singly Linkedì™€ ìœ ì‚¬í•¨
- ë°°ì—´ê³¼ ìœ ì‚¬í•˜ë‚˜ ë‹¤ë¦„
- í…Œì¼ í—¤ë“œ ìˆìŒ
- ëª¨ë“  ë…¸ë“œê°€ next, previous attributesê°€ ìˆìŒ.
- ìœ ì—°ì„±ì´ ë” ìˆëŠ” ë§Œí¼ ë©”ëª¨ë¦¬ê°€ ë§ì´ ë“¦(next+previousë¥¼ ì €ì¥í•´ì•¼ í•¨ìœ¼ë¡œ)

## ê¸°ë³¸ êµ¬ì¡° ë§Œë“¤ê¸°

```jsx
class Node {
	constructor(val){
		this.val = val;
		this.next = null;
		this.prev = null;
	}
}

class DoublyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}
}
```

## Push

ë…¸ë“œë‚˜ ê°’ì„ ì´ì¤‘ì—°ê²°ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€

## Push pseudocode

- ê°’ì„ ê°€ì§€ëŠ” ìƒˆë¡œìš´ ë…¸ë“œ ë§Œë“¤ê¸°
- í—¤ë“œê°€ nullì¸ì§€ ì•„ë‹ˆë©´ ê¸¸ì´ê°€ 0 ì¸ì§€ í™•ì¸(ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì–´ìˆëŠ”ì§€)
    - ë¹„ì–´ ìˆìœ¼ë©´ head,tailì´ ëª¨ë‘ ìƒˆë¡œìš´ ë…¸ë“œë¡œ ì„¤ì •
    - ë¹„ì–´ ìˆì§€ ì•Šë‹¤ë©´ í˜„ì¬ ì–‘ë°©í–¥ ë¦¬ìŠ¤íŠ¸ì˜ í…Œì¼ì˜ next ì†ì„±ì— ìƒˆë¡œìš´ ë…¸ë“œë¥¼ ì¶”ê°€
    - ê·¸ë¦¬ê³  ìƒˆë¡œìš´ ë…¸ë“œì˜ prevì†ì„±ì— í…Œì¼ì„ ì¶”ê°€
- ê¸¸ì´ë¥¼ 1 ì˜¬ë ¤ì¤Œ
- ë³€ê²½ëœ Doubly Linked Listë¥¼ ë°˜í™˜

```jsx
push(val){
	const newNode = new Node(val);
	if(!this.length){
		this.head = newNode;
		this.tail = newNode;
	} else{
		this.tail.next = newNode;
		newNode.prev = this.tail;
		this.tail = newNode;
	}
	this.length++;
	return this;
}
```

## Pop

ì œì¼ ë’¤ì— ìˆëŠ” ë…¸ë“œ ì œê±°

## Popping pseudocode

- í—¤ë“œ(í…Œì¼)ì´ ì—†ë‹¤ë©´ return undefined
    - í…Œì¼ì„ ë‚˜ì¤‘ì— ì¶œë ¥í•˜ë„ë¡ ë³€ìˆ˜ì— ì €ì¥
    - ê¸¸ì´ê°€ 0 ì´ë¼ë©´ í—¤ë“œì™€ í…Œì¼ì´ ë‘˜ë‹¤ nullì´ ë˜ë„ë¡ ì„¤ì •
    - í…Œì¼ì´ ê·¸ ì „ì— ìˆë˜ ë…¸ë“œê°€ ë˜ë„ë¡ ì„¤ì •(prev)
    - ìƒˆë¡œìš´ tailì˜ next ì†ì„±ì„ nullë¡œ ì„¤ì •
- ê¸¸ì´ë¥¼ ì¤„ì„
- ì œê±°í•œ ë…¸ë“œë¥¼ ë¦¬í„´!

```jsx
pop(){
	if(!this.head || !this.tail){
		return undefined;
	}
	const poppedNode = this.tail;
	if(this.length === 1){
		this.head = null;
		this.tail = null;
	} else{
		this.tail = poppedNode.prev;
		this.tail.next = null;
		//ì•ˆí•˜ë©´ listì—ì„œëŠ” ì—°ê²°ì´ ëŠê²¨ë„ popí•œ ë…¸ë“œì—ì„œì˜ ì—°ê²°ì´ ë‚¨ì•„ìˆê²Œ ë¨.
		poppedNode.prev = null;
	}
	this.length--;
	return poppedNode;
}
```

## Shift

ë§¨ ì•ì˜ ë…¸ë“œ í•˜ë‚˜ ì œê±°

## Shifting pseudocode

- ê¸¸ì´ê°€ 0ì¸ì§€ í™•ì¸í•˜ê³ 
    - ê¸¸ì´ 0 ì´ë©´ return undefined;
    - ì•„ë‹ˆë©´ í˜„ì¬ í—¤ë“œ ë…¸ë“œë¥¼ ë³€ìˆ˜(oldHead)ì— ì €ì¥
    - ê¸¸ì´ê°€ 1ì´ë©´
        - head, tailì„ nullë¡œ ë³€ê²½
    - ê¸¸ì´ê°€ 1ë³´ë‹¤ í¬ë©´ í—¤ë“œë¥¼ oldHead.nextì˜ ë…¸ë“œë¡œ ë³€ê²½
    - ê·¸ë¦¬ê³  ì—…ë°ì´íŠ¸í•œ í—¤ë“œì˜ prev ì†ì„±ì„ nullë¡œ ë³€ê²½
    - oldHeadì˜ nextë¥¼ nullë¡œ ë³€ê²½
    - ê¸¸ì´ 1 ì¤„ì´ê¸°
    - oldHeadë¥¼ ë°˜í™˜

```jsx
shift(){
	if(!this.length) return undefined;
	const oldHead = this.head;

	if(this.length === 1){
		this.head = null;
		this.tail = null;
	}else{
		this.head = oldHead.next;
		this.head.prev = null;
		oldHead.next = null;
	}

	this.length--;
	return oldHead;
}
```

## Unshift

ì œì¼ ì•ì— ë…¸ë“œí•˜ë‚˜ ì¶”ê°€

## Unshifting pseudocode

- ë°›ì€ ê°’ìœ¼ë¡œ ìƒˆë¡œìš´ ë…¸ë“œ ìƒì„±
- ê¸¸ì´ê°€ 0 ì´ë¼ë©´ ë¹„ì–´ìˆìœ¼ë¯€ë¡œ
    - head, tailì„ ìƒˆë¡œìš´ ë…¸ë“œë¡œ ì„¤ì •
- ê¸¸ì´ê°€ 0ì´ ì•„ë‹ˆë©´ head ë…¸ë“œì˜ prev ì†ì„±ì„ ìƒˆë¡œìš´ ë…¸ë“œë¡œ
    - ìƒˆë¡œìš´ ë…¸ë“œì˜ nextí”„ë¡œí¼í‹°ë¥¼ headë…¸ë“œë¡œ ë§ì¶°ì£¼ë©´ ë¨
    - ê·¸ë¦¬ê³  headë¥¼ ìƒˆë¡œìš´ ë…¸ë“œë¡œ ë³€ê²½
- ê¸¸ì´ 1 ì¦ê°€
- ë¦¬ìŠ¤íŠ¸ ë°˜í™˜

```jsx
unshift(val){
	const newNode = new Node(val);
	if(!this.length){
		this.head = newNode;
		this.tail = newNode;
	}else{
		this.head.prev = newNode;
		newNode.next = this.head;
		this.head = newNode;
	}
	this.length++;
	return this;
}
```

## Get

ìˆ«ì(ì¸ë±ìŠ¤)ë¥¼ ì…ë ¥í•˜ì—¬ í•´ë‹¹ ìœ„ì¹˜(ì¸ë±ìŠ¤)ì˜ ë…¸ë“œë¥¼ ì°¾ì•„ë‚´ëŠ” ê²ƒ

- ë‹¨ì¼ì—°ê²°ë¦¬ìŠ¤íŠ¸ëŠ” ì²˜ìŒë¶€í„° í•´ë‹¹ ìˆ«ìê¹Œì§€ íšŒë¬¸ì„ ëŒì•˜ì–´ì•¼í•¨
- ì–‘ë°©í–¥ì€ prevë„ ìˆê¸°ë•Œë¬¸ì— ì•, ë’¤ ëª¨ë‘ì—ì„œ íšŒë¬¸ì„ ëŒë¦´ ìˆ˜ ìˆê¸°ë•Œë¬¸ì— ìš”êµ¬ë˜ëŠ” Indexì—ë”°ë¼ íšŒë¬¸ ì‹œì‘ ìœ„ì¹˜ë¥¼ ë°”ê¿”ì£¼ë©´ ë‹¨ì¼ì—°ê²°ë¦¬ìŠ¤íŠ¸ë³´ë‹¤ëŠ” ìµœì í™”ê°€ ë˜ëŠ” ê²ƒ.

## Get pseudocode

- ì¸ë±ìŠ¤ê°€ 0 ë³´ë‹¤ ì‘ê±°ë‚˜ ê¸¸ì´ë³´ë‹¤ í¬ë©´ return null;(ê¸¸ì´ë‘ ê°™ì•„ë„ ì•ˆë˜ëŠ”ê±´ ì¸ë±ìŠ¤ì´ë‹ˆê¹Œ ì•ˆë¨)
- ì¸ë±ìŠ¤ê°€ ê¸¸ì´ì˜ ì ˆë°˜ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ìœ¼ë©´
    - headë¶€í„° middleê¹Œì§€ ë£¨í”„ë¥¼ ëŒê³  ì°¾ì€ ë…¸ë“œ ë°˜í™˜
- ì¸ë±ìŠ¤ê°€ ê¸¸ì´ì˜ ì ˆë°˜ë³´ë‹¤ í¬ë©´
    - tailë¶€í„° middleê¹Œì§€ ë£¨í”„ë¥¼ ëŒì•„ì„œ ì°¾ì€ë…¸ë“œ ë°˜í™˜

### No-Optimize

```jsx
get(index){
	if(index < 0 || index >= this.length)return null;
	const count = 0;
	const current = this.head;
	while(count != index){
		current = current.next;
		count++;
	}
	return current;
}
```

### Optimize

```jsx
get(index){
	if(index < 0 || index >= this.length)return null;
	const count = 0;
	const current = this.head;

	if(index <= this.length/2){
		const count = 0;
		const current = this.head;		
		while(count != index){
			current = current.next;
			count++;
		}
	}else{
		const count = this.length - 1;
		const current = this.head;		
		while(count != index){
			current = current.prev;
			count--;
		}
	}

	return current;
}
```

## Set

ë°›ì€ ì¸ë±ìŠ¤ì˜ ë…¸ë“œ ê°’ì„ ë°›ì€ ê°’ìœ¼ë¡œ ë³€ê²½í•˜ëŠ” ê²ƒ

## Set pseudocode

- get ë©”ì„œë“œë¥¼ í†µí•´ ë°›ì€ ë…¸ë“œë¥¼ ë³€ìˆ˜ì— ì €ì¥
    - getë©”ì„œë“œê°€ ìœ íš¨í•œ ë…¸ë“œë¥¼ ë°˜í™˜í•˜ë©´ ê·¸ ë…¸ë“œì˜ ê°’ì„ ë°›ì€ ì¸ìì˜ ê°’ìœ¼ë¡œ ë³€ê²½
    - return true
    - ìœ íš¨í•˜ì§€ ì•Šì€ ë…¸ë“œ ë°˜í™˜ ì‹œ return false

```jsx
set(index, val){
	const foundNode = this.get(index);
	if(foundNode !== null){
		foundNode.val = val;
		return true;
	}
	return false;
}
```

## Insert

ìœ„ì¹˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì¸ë±ìŠ¤ì™€ ê°’í•˜ë‚˜ë¥¼ ë„£ê³  í•´ë‹¹ ì¸ë±ìŠ¤ì— ìƒˆë¡œìš´ ê°’ìœ¼ë¡œ ë§Œë“  ë…¸ë“œë¥¼ ë„£ìŒ.

## Insert pseudocode

- ì¸ë±ìŠ¤ê°€ 0 ë³´ë‹¤ ì‘ê±°ë‚˜ ê¸¸ì´ë³´ë‹¤ í° ê²½ìš° Return false
- 0ì´ë©´ unshift
- ì¸ë±ìŠ¤ê°€ ê¸¸ì´ë‘ ê°™ìœ¼ë©´ Push
- ì´ ê²½ìš°ê°€ ì•„ë‹ˆë©´ getë©”ì„œë“œë¥¼ index-1í•œ ê°’ìœ¼ë¡œ ê°€ì ¸ì˜¤ê¸°
- nextì™€ prev ì†ì„±ì„ ì‚¬ìš©í•´ì„œ ë…¸ë“œë“¤ì„ ì—°ê²°í•´ì¤Œ
- ê¸¸ì´ë¥¼ 1 ì˜¬ë¦¬ê³ 
- return true

```jsx
insert(index,val){
	if(index < 0 || index > this.length) return false;
	if(index === 0) return !!this.unshift(val);
	if(index === this.length) return !!this.push(val);

	const newNode = new Node(val);
	const beforeNode = this.get(index-1);
	const afterNode = beforeNode.next;

	beforeNode.next = newNode, newNode.prev = beforeNode;
	newNode.next = afterNode, afterNode.prev = newNode;
	this.length++;
	return true;
}
```

## Remove

íŠ¹ì • ìœ„ì¹˜ì˜ ë…¸ë“œ ì‚­ì œ

## Remove pseudocode

- ì¸ë±ìŠ¤ ìœ íš¨ì„± í™•ì¸(0ë³´ë‹¤ ì‘ì€ì§€ ê¸¸ì´ë³´ë‹¤ í°ì§€)
    - ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ return undefined
    - ì¸ë±ìŠ¤ 0 â‡’ shift
    - ê¸¸ì´-1ê³¼ ê°™ìœ¼ë©´ â‡’ pop
    - ë‚˜ë¨¸ì§€ëŠ” getë©”ì„œë“œë¥¼ ì‚¬ìš©í•´ì„œ ì œê±°í•´ì•¼í•  ìš”ì†Œë¥¼ ì°¾ìŒ
        - ê·¸ëŸ¬ê³  next,prevë¥¼ ë°”ê¿”ì„œ ìš”ì†Œë¥¼ ì˜ ë§¤ê¿”ì¤Œ
        - ì°¾ì•„ë‚¸ ë…¸ë“œì˜ next,prevë¥¼ nullë¡œ ë°”ê¾¸ê³ 
        - ê¸¸ì´ 1 ì¤„ì´ê³ 
        - ì°¾ì•„ë‚¸ ë…¸ë“œë¥¼ ë°˜í™˜

```jsx
remove(index){
	if(index < 0 || index >= this.length) return undefined;	
	if(index === 0) return this.shift();
	if(index === this.length - 1) return this.pop();

	const removedNode = this.get(index);
	const beforeNode = removedNode.prev;
	const afterNode = removedNode.next;

	beforeNode.next = afterNode;
	afterNode.prev= beforeNode;
	removedNode.next = null;
	removedNode.prev = null;
	this.length--;

	return removedNode;
}
```

# Doubly Linked List Summary

```jsx
class Node {
	constructor(val){
		this.val = val;
		this.next = null;
		this.prev = null;
	}
}

class DoublyLinkedList {
	constructor(){
		this.head = null;
		this.tail = null;
		this.length = 0;
	}

	push(val){
		const newNode = new Node(val);
		if(!this.length){
			this.head = newNode;
			this.tail = newNode;
		} else{
			this.tail.next = newNode;
			newNode.prev = this.tail;
			this.tail = newNode;
		}
		this.length++;
		return this;
	}

	pop(){
		if(!this.head || !this.tail){
			return undefined;
		}
		const poppedNode = this.tail;
		if(this.length === 1){
			this.head = null;
			this.tail = null;
		} else{
			this.tail = poppedNode.prev;
			this.tail.next = null;
			//ì•ˆí•˜ë©´ listì—ì„œëŠ” ì—°ê²°ì´ ëŠê²¨ë„ popí•œ ë…¸ë“œì—ì„œì˜ ì—°ê²°ì´ ë‚¨ì•„ìˆê²Œ ë¨.
			poppedNode.prev = null;
		}
		this.length--;
		return poppedNode;
	}

	shift(){
		if(!this.length) return undefined;
		const oldHead = this.head;
	
		if(this.length === 1){
			this.head = null;
			this.tail = null;
		}else{
			this.head = oldHead.next;
			this.head.prev = null;
			oldHead.next = null;
		}
	
		this.length--;
		return oldHead;
	}

	unshift(val){
		const newNode = new Node(val);
		if(!this.length){
			this.head = newNode;
			this.tail = newNode;
		}else{
			this.head.prev = newNode;
			newNode.next = this.head;
			this.head = newNode;
		}
		this.length++;
		return this;
	}

	get(index){
		if(index < 0 || index >= this.length)return null;
		const count = 0;
		const current = this.head;
	
		if(index <= this.length/2){
			const count = 0;
			const current = this.head;		
			while(count != index){
				current = current.next;
				count++;
			}
		}else{
			const count = this.length - 1;
			const current = this.head;		
			while(count != index){
				current = current.prev;
				count--;
			}
		}
	
		return current;
	}
	
	set(index, val){
		const foundNode = this.get(index);
		if(foundNode !== null){
			foundNode.val = val;
			return true;
		}
		return false;
	}
	
	insert(index,val){
		if(index < 0 || index > this.length) return false;
		if(index === 0) return !!this.unshift(val);
		if(index === this.length) return !!this.push(val);
	
		const newNode = new Node(val);
		const beforeNode = this.get(index-1);
		const afterNode = beforeNode.next;
	
		beforeNode.next = newNode, newNode.prev = beforeNode;
		newNode.next = afterNode, afterNode.prev = newNode;
		this.length++;
		return true;
	}

	remove(index){
		if(index < 0 || index >= this.length) return undefined;	
		if(index === 0) return this.shift();
		if(index === this.length - 1) return this.pop();
	
		const removedNode = this.get(index);
		const beforeNode = removedNode.prev;
		const afterNode = removedNode.next;
	
		beforeNode.next = afterNode;
		afterNode.prev= beforeNode;
		removedNode.next = null;
		removedNode.prev = null;
		this.length--;
	
		return removedNode;
	}
}
```

## ì´ì¤‘ì—°ê²°ë¦¬ìŠ¤íŠ¸ BIG O

**Insertion**: O(1)

**Removal**: O(1)

ë‹¨ì¼ ì—°ê²°ë¦¬ìŠ¤íŠ¸ì˜ ê²½ìš° íšŒë¬¸ì„ ì „ì²´ ëŒì•„ì•¼í•˜ì§€ë§Œ(O(N)) ì´ì¤‘ì—°ê²°ë¦¬ìŠ¤íŠ¸ëŠ” ê·¸ëŸ´ í•„ìš”ê°€ ì—†ìŒ

`.prev` ì†ì„±ì´ ìˆê¸° ë•Œë¬¸

**Searching**: O(N)

ì´ë¡ ì ìœ¼ë¡œ Searchingì€ O(N/2)ì´ê¸´ í•œë° (ì¸ë±ìŠ¤ì— ë”°ë¼ ì• ë’¤ì—ì„œ ì‹œì‘ ê°€ëŠ¥í•˜ë¯€ë¡œ)

ê²°êµ­ ,ê·¸ë˜ë„ O(N)ì´ë‘ ê°™ìŒ

**Access**: O(N)

## Recap

- ì´ì¤‘ì—°ê²°ë¦¬ìŠ¤íŠ¸ëŠ” prevë¹¼ê³  ë‹¨ì¼ì—°ê²°ë¦¬ìŠ¤íŠ¸ë‘ ê±°ì˜ ê°™ìŒ
- ë…¸ë“œë¥¼ ì°¾ì„ ë•Œ ë‹¨ì¼ ì—°ê²°ë¦¬ìŠ¤íŠ¸ì— ë¹„í•´ ì ˆë°˜ì˜ ì‹œê°„ì´ ê±¸ë¦¼
    - prevì†ì„± ë•ì— ì¸ë±ìŠ¤ì˜ ìœ„ì¹˜ë¥¼ í†µí•´ ì¤‘ê°„ë³´ë‹¤ ê¸¸ë©´ ë’¤ì—ì„œì‹œì‘ì´ ê°€ëŠ¥í•˜ë¯€ë¡œ
- ê·¸ëŸ°ë° prev ì†ì„±ì´ ì¶”ê°€ë˜ë¯€ë¡œ ì¶”ê°€ì ì¸ ë©”ëª¨ë¦¬ë¥¼ ë¨¹ìœ¼ë‹ˆ ì—¼ë‘í•´ì•¼ í•¨



# Stack(ìŠ¤íƒ)

í›„ì…ì„ ì¶œ(Last In Fisrt Out) ì›ì¹™ë”°ë¥´ëŠ” ë°ì´í„° ëª¨ìŒ

## ì‚¬ìš©ì²˜

- í•¨ìˆ˜ í˜¸ì¶œì„ ë‹¤ë£¨ëŠ” ìƒí™© (ì½œìŠ¤íƒ)
- Undo/ Redo (ê°€ì¥ ìµœê·¼ ì•¡ì…˜ì„ ì—†ì• ì•¼ í•˜ë¯€ë¡œ ã…ã……ã…)
- Routing(history object)ê°€ ìŠ¤íƒì²˜ëŸ¼ ë‹¤ë¤„ì§€ê¸°ë„ í•¨(ë°©ë¬¸ í˜ì´ì§€ ê¸°ë¡ ë“±..)
- ì•Œê³ ë¦¬ì¦˜

## êµ¬ì„±

- ë°°ì—´ë„ ë¨

```jsx
const stack = [];
stack.push("google");
stack.push("instagram");
stack.push("youtube");
console.log(stack); //["google", "instagram", "youtube"];
stack.pop()//"youtube"
stack.push("amazon");
stack.pop()//"amazon"
/*
ì•ì—ì„œ ë‹¤ ë‹¤ë£°ìˆ˜ë„ ìˆê¸´ í•¨(ê°œë…ì ìœ¼ë¡œëŠ” ìŠ¤íƒì²˜ëŸ¼ ì‚¬ìš© ê°€ëŠ¥)
ì´ë ‡ê²Œ í•˜ë©´ ì¸ë±ìŠ¤ë¥¼ ë‹¤ ë°€ì–´ì•¼í•´ì„œ(re-index) BIG Oê°€ Nì„
push, popì€ BIG Oê°€ O(1)ê°€ ë¨ ê°œê¿€(ì¸ë±ìŠ¤ ì•ˆê±´ë“œë ¤ë„ ë¨)
*/
stack.unshift("A");
stack.unshift("B");
stack.unshift("C");
console.log(stack); // ["C","B","A"];
stack.shift(); // "A"
```

- ë§í¬ë“œë¦¬ìŠ¤íŠ¸ë„ ë¨
    - ê¸°ì¡´ singly linked listì˜ popë©”ì„œë“œë¥¼ ì“°ë©´ ì•ì—ì„œë¶€í„° ë§ˆì§€ë§‰ìœ¼ë¡œ ê°€ê¸°ë•Œë¬¸ì— O(N)ì´ ê±¸ë¦¬ë¯€ë¡œ íš¨ìœ¨ì´ ì—†ìŒ
    - ëŒ€ì‹ ì— shift() , unshift()ë¥¼ í™œìš©
        - ë§¨ë’¤ì—ì„œ push, popì„ í•˜ëŠ” ëŒ€ì‹  ë§¨ ì•ì—ì„œ push, popì„ ì‹œí‚¤ëŠ” ë°©ì‹(ì´ëŸ¬ë©´ ìƒìˆ˜ì‹œê°„ ê°€ëŠ¥ :))

### push ìˆ˜ë„ì½”ë“œ

- ìŠ¤íƒì´ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸
    - ë¹„ì–´ìˆìœ¼ë©´ first, last ì†ì„±ì„ newNodeë¡œ ì„¤ì •
    - í•˜ë‚˜ë¼ë„ ë…¸ë“œ ìˆìœ¼ë©´ ë³€ìˆ˜ë§Œë“¤ì–´ì„œ í˜„ì¬ Stackì˜ firstë¥¼ ë³€ìˆ˜ì— ì €ì¥
    - firstì†ì„±ì„ ìƒˆë¡œë§Œë“  ë…¸ë“œë¡œ ë³€ê²½(newNode)
    - firstì˜ next ì†ì„±ì„ ë³€ìˆ˜ì— ì €ì¥í•œ ë…¸ë“œë¡œ í• ë‹¹
- ì‚¬ì´ì¦ˆ ì˜¬ë¦¼
- ì‚¬ì´ì¦ˆ ë°˜í™˜

### pop ìˆ˜ë„ì½”ë“œ

- ìŠ¤íƒì— ë…¸ë“œê°€ ìˆëŠ”ì§€ ì—†ëŠ” ì§€í™•ì¸
    - ë¹„ì–´ìˆìœ¼ë©´ null ì¶œë ¥
    - ì•ˆ ë¹„ì–´ìˆìœ¼ë©´ firstí”„ë¡œí¼í‹°ë¥¼  ë³€ìˆ˜ì— ì €ì¥í•˜ê³ 
    - ê°€ì¥ ë§ˆì§€ë§‰ì— ì¶œë ¥í•´ì¤Œ
    - ë…¸ë“œê°€ í•˜ë‚˜ë¿ì´ë©´ first, last ë‘˜ë‹¤ null
    - í•˜ë‚˜ë³´ë‹¤ ë§ìœ¼ë©´ firstë¥¼ ë³€ìˆ˜ì— ì €ì¥í•œ ë…¸ë“œì˜ nextë¡œ ë°”ê¿”ì¤Œ
- ì‚¬ì´ì¦ˆ í•˜ë‚˜ ì¤„ì„
- ë³€ìˆ˜ì €ì¥í•œ ë…¸ë“œ ë°˜í™˜

```jsx
class Node {
	constructor(value){
		this.value = value;
		this.next = null;
		}
}

class Stack {
	constructor(){
		this.first = null;
		this.last = null;
		this.size = 0;
	}

	push(val) {
		const newNode = new Node(val);
		if(!this.first){
				this.first = newNode;
				this.last = newNode;
		} else{
			const temp = this.first;
			this.first = newNode;
			this.first.next = temp;
			return ++this.isze;
		}
	}

	pop(){
		if(!this.first)return null;
		const temp = this.first;
		if(this.first === this.last){
			this.last = null;
		}
		this.first = this.first.next;
		this.size--;
		return temp,value;
	}
}
```

## BIG O of STACKS

ì‚½ì…ê³¼ ì œê±°ê°€ ìƒìˆ˜ì‹œê°„ì´ ë˜ëŠ”ê²Œ ìŠ¤íƒì—ì„œ ì ¤ ì¤‘ìš”í•¨

- Insertion - O(1)
- Removal - O(1)
- Searching - O(N)
- Access - O(N)

## Stack Recap

- LIFO
- ìŠ¤íƒì€ ì‹¤í–‰ì·¨ì†Œë‚˜ ë¸Œë¼ìš°ì € ê¸°ë¡ ì €ì¥ë“±ì— ì‚¬ìš©ë¨
- JSì—ì„œëŠ” ì§€ì›ì•ˆí•´ì¤Œ ã…‹
- ì•Œê³ ë¦¬ì¦˜ì—ì„œëŠ” ê·¸ëƒ¥ ë°°ì—´ ì“°ëŠ”ê²Œí¸í•¨


# (Queues)í

ì„ ì…ì„ ì¶œ(First In First Out) ì›ì¹™ë”°ë¥´ëŠ” ë°ì´í„° ëª¨ìŒ

## ì‚¬ìš©ì²˜

- ì¤„ì„œê±°ë‚˜
- í”„ë¡œê·¸ë˜ë°ì—ì„œëŠ”
    - ì˜¨ë¼ì¸ì ‘ì† ê²Œì„ ëŒ€ê¸°
    - ì»´í“¨í„° ë°±ê·¸ë¼ìš´ë“œ ì‘ì—…
    - íŒŒì¼ ì—…ë¡œë“œ
    - í”„ë¦°íŠ¸ ëŒ€ê¸°ì—´

## êµ¬ì„±

ë°°ì—´ë¡œ í•´ë´„

```jsx
let q = [];
q.push("FIRST");
q.push("SECOND");
q.push("THIRD");
console.log(q);//["FIRST", "SECOND", "THIRD"];
q.shift(); //"FIRST" //ì´ëŸ¬ë©´ ë¦¬ì¸ë±ì‹± ë‹¤í•´ì„œ O(N)ë¨

q = [];
q.unshift("FIRST");
q.unshift("SECOND");
q.unshift("THIRD");
console.log(q);//["THIRD", "SECOND", "FIRST"];
q.pop() //"FIRST" //ì´ë ‡ê²Œ í•˜ë©´ ì²˜ìŒì— ë„£ì„ë–„(unshift) ë¦¬ì¸ë±ì‹± í•˜ë¯€ë¡œ O(N)ì´ ë¨

```

í´ë˜ìŠ¤ë¡œ ì§ì ‘ ë§Œë“¤ì–´ë²„ë¦¬ê¸°

- ìŠ¤íƒì—ì„œ ë´¤ë˜ ë‹¨ì¼ ì—°ê²°ë¦¬ìŠ¤íŠ¸ì˜ ë¬¸ì œì²˜ëŸ¼ popì„ ì‚¬ìš©í•˜ë©´ ì „ì²´ë¥¼ íšŒë¬¸í•˜ì—¬ tailì„ ì°¾ì•„ì•¼í•˜ë¯€ë¡œ
- íë¥¼ êµ¬ì„±í• ë•Œ ë§¨ ë’¤ì— ì¶”ê°€í•˜ê³  ë§¨ ì•ì—ì„œ ì œê±°í•˜ë©´ ìƒìˆ˜ì‹œê°„ìœ¼ë¡œ ë§Œë“¤ ìˆ˜ ìˆê²Œ ë¨.

```jsx
class Node{
	constructor(value){
		this.value = value;
		this.next = null;	
	}
}

class Queue {
	constructor(){
		this.first = null;
		this.last = null;
		this.size = 0;
	}

	enqueue(val){
		//ë¦¬ìŠ¤íŠ¸ ê°€ì¥ ë’¤ì— ì¶”ê°€
		const newNode = new Node(val);
		if(!this.first){
			this.first = newNode;
			this.last = newNode;
		}else{
			this.last.next = newNode;
			this.last = newNode;
		}
		return ++this.length;
	}

	dequeue(){
		//ë¦¬ìŠ¤íŠ¸ ê°€ì¥ ì•ì„ ì œê±°
		if(!this.first) return null;
		const temp = this.first;
		if(this.first === this.last){
			this.last = null;
		}
		this.first = this.first.next;
		this.size--;
		return temp.value;
	}
}
```

### enqueue pseudo code

- ì¸ì ë°›ìŒ
- ë°›ì€ ì¸ìë¡œ ìƒˆë¡œìš´ ë…¸ë“œ ë§Œë“¦
- ë§Œì•½ íê°€ ë¹„ì–´ìˆìœ¼ë©´ í•´ë‹¹ ë…¸ë“œë¥¼ first, last ì†ì„±ìœ¼ë¡œ ì •ì˜
- íê°€ ë¹„ ì–´ìˆì§€ ì•Šë‹¤ë©´ íì˜ í˜„ì¬ lastì˜ nextë¥¼ ìƒˆë¡œìš´ ë…¸ë“œë¡œ ë³€ê²½
    - ìƒˆë¡œìš´ ë…¸ë“œë¥¼ íì˜ lastë¡œ ì§€ì •
- ê¸¸ì´ í•˜ë‚˜ ì¶”ê°€í•˜ê³  ê¸¸ì´ ë¦¬í„´

### dequeue pseudo code

- íì˜ firstì†ì„±ì´ ë¹„ì–´ìˆìœ¼ë©´ nullì¶œë ¥
- firstì†ì„±ì„ ë³€ìˆ˜ì— ì €ì¥
- firstê°€ lastì™€ ê°™ìœ¼ë©´ (ë…¸ë“œ í•˜ë‚˜ë©´) first,lastë¥¼ nullë¡œ ì„¤ì •
- í•˜ë‚˜ ì´ìƒì˜ ë…¸ë“œê°€ ìˆìœ¼ë©´ íì˜ firstë¥¼ first.nextì˜ ë…¸ë“œë¡œ ì„¤ì •
- ê¸¸ì´ í•˜ë‚˜ ê°ì†Œ
- ê·¸ë¦¬ê³  ì œê±°í•œ ë…¸ë“œì˜ ê°’ ë°˜í™˜

## BIG O of QUEUES

ì‚½ì…ê³¼ ì œê±°ê°€ ìƒìˆ˜ì‹œê°„ì´ ë˜ëŠ”ê²Œ íì—ì„œ ì ¤ ì¤‘ìš”í•¨

ìŠ¤íƒê³¼ëŠ” ë‹¤ë¥´ê²Œ ë°°ì—´ì„ í ìš©ë„ë¡œ ì‚¬ìš©í•˜ë©´ ìƒìˆ˜ì‹œê°„ì´ ë‚˜ì˜¤ì§€ ì•ŠëŠ” ê²ƒì„ ê¼­ ê¸°ì–µí•˜ì

- Insertion - O(1)
- Removal - O(1)
- Searching - O(N)
- Access - O(N)

## QUEUES Recap

- FIFO
- íëŠ” ì¤„ì„œëŠ” ê²ƒ ê³¼ ê°™ìŒ ë§¨ì•ì— ì„ ì‚¬ëŒì´ ì œì¼ ë¨¼ì € ë‚˜ì˜´
- JSì—ì„œëŠ” ì§€ì›ì•ˆí•´ì¤Œ ã…‹

# íŠ¸ë¦¬(Tree)

- ì—°ê²°ë¦¬ìŠ¤íŠ¸ì²˜ëŸ¼ ë…¸ë“œë¡œ ì´ë£¨ì–´ì§„ ë°ì´í„° êµ¬ì¡°
    - parent, childêµ¬ì¡°ê°€ ìˆìŒ
- List: linear, Trees: Non-linear
- ë‹¤ë¥´ê²Œ ìƒê°í•´ë³´ë©´ Singly Linked ListëŠ” íŠ¸ë¦¬ì˜ íŠ¹ë³„í•œ ì¼€ì´ìŠ¤ì¤‘ í•˜ë‚˜ë¼ê³  ë³´ë©´ ë¨.
- íŠ¸ë¦¬ëŠ” ëª¨ë“  ë…¸ë“œê°€ ë£¨íŠ¸ì—ì„œ ë©€ì–´ì§€ëŠ” ë°©ì‹(ê°™ì€ ë ˆë²¨ì—ì„œ ì„œë¡œ ì—°ê²°ë˜ê±°ë‚˜ í•˜ë©´ ì•ˆë¨â†’ê·¸ëŸ¬ë©´ ê·¸ë˜í”„ë¨ ã…)

## íŠ¸ë¦¬ìš©ì–´

- Root: íŠ¸ë¦¬ì—ì„œ ê°€ì¥ ìƒìœ„ ë…¸ë“œ
- Child: ë£¨íŠ¸ì—ì„œ ë©€ì–´ì§€ëŠ” ë°©í–¥ìœ¼ë¡œ ì—°ê²°ëœ ë…¸ë“œ
- Parent: Childì˜ ë°˜ëŒ€ê°œë…
- Siblings: ê°™ì€ Parent Nodeë¥¼ ê°€ì§„ ë…¸ë“œ
- Leaf(ë§ˆì§€ë§‰ ë…¸ë“œ): Childrenì´ ì—†ëŠ” ë…¸ë“œ
- Edge(ê°„ì„ ): í•œ ë…¸ë“œì—ì„œ ë‹¤ë¥¸ ë…¸ë“œë¡œ í–¥í•˜ëŠ” í™”ì‚´í‘œ

## íŠ¸ë¦¬ ì‚¬ìš©ì²˜

- HTML, DOM
- ë„¤íŠ¸ì›Œí¬ ë¼ìš°íŒ…
- ì¶”ìƒêµ¬ë¬¸íŠ¸ë¦¬(í”„ë¡œê·¸ë˜ë° ì–¸ì–´ êµ¬ë¬¸ì„ ë³´ì—¬ì£¼ëŠ” ë°©ë²• ì¤‘ í•˜ë‚˜)
- AI(ê²°ì •íŠ¸ë¦¬)
- OSì˜ í´ë”(ëª¨ë‘ ì„œì—´ì´ ìˆìŒ ã…)
- JSON

# ì´ì§„íŠ¸ë¦¬(Binary Tree)

- ëª¨ë“  ë¶€ëª¨ë…¸ë“œ(parent node)ëŠ” ìµœëŒ€ 2ê°œì˜ ìì‹ ê°€ì§(0,1,2ê°œì˜ ìì‹ì´ ê°€ëŠ¥í•˜ë‹¨ë§)

## ì´ì§„ íƒìƒ‰íŠ¸ë¦¬(Binary Search Tree)

- ëª¨ë“  ë¶€ëª¨ë…¸ë“œ(parent node)ëŠ” ìµœëŒ€ 2ê°œì˜ ìì‹ ê°€ì§
- ë¶€ëª¨ ë…¸ë“œë³´ë‹¤ ì‘ì€ ê°’ì€ ëª¨ë‘ ì¢Œì¸¡ ìì‹ íŠ¸ë¦¬ë¡œ , í°ê°’ì€ ìš°ì¸¡ ìì‹ íŠ¸ë¦¬ë¡œ

## ì´ì§„íƒìƒ‰íŠ¸ë¦¬ ê²€ìƒ‰

- ì¢Œ ìš°ë¡œ í¬ê¸°ë¥¼ í†µí•´ ë‚˜ë‰˜ì–´ì ¸ ìˆì–´ ë§¤ë²ˆ ë¹„êµì‹œì— íƒìƒ‰ì„ í•´ì•¼í•˜ëŠ” ìˆ«ìê°€ ì ˆë°˜ìœ¼ë¡œ ì¤„ì–´ë“¤ ìˆ˜ ìˆìŒ(ì´ì§„íƒìƒ‰ì˜ ì›ë¦¬ë¥¼ ìƒê°í•´ë³´ì)

## ì´ì§„ê²€ìƒ‰íŠ¸ë¦¬ ë¼ˆëŒ€(Skeleton)

```jsx
class Node {
	constructor(value){
		this.value = value;
		this.left = null;
		this.right = null;
	}
}

class BinarySearchTree {
	constructor(){
		this.root = null;
	}
}
```

## Insert ë©”ì„œë“œ

ìƒˆë¡œìš´ ë…¸ë“œë¥¼ ìœ„ì¹˜ì— ë§ê²Œ ì‚½ì…

## Inserting pseudo code

- ë°›ì€ ê°’ìœ¼ë¡œ ë…¸ë“œ ìƒì„±
- ë£¨íŠ¸ë¶€í„° ì‹œì‘
    - ë£¨íŠ¸ê°€ ì´ì§„íƒìƒ‰íŠ¸ë¦¬ì— ìˆëŠ”ì§€ ì—†ëŠ”ì§€ í™•ì¸
        - ì—†ìœ¼ë©´ rootì— í•´ë‹¹ ë…¸ë“œ í• ë‹¹
    - ìˆìœ¼ë©´ ìƒˆë¡œìš´ ë…¸ë“œì˜ ê°’ì´ í˜„ì¬ ë£¨íŠ¸ë³´ë‹¤ í°ì§€ ì‘ì€ì§€ íŒë³„
        - í¬ë©´
            - right ì†ì„±ì— ë…¸ë“œê°€ ìˆëŠ”ì§€ í™•ì¸
            - ìˆìœ¼ë©´ .right ë¡œ ë„˜ì–´ê°€ì„œì´ ê³¼ì •ì„ ë°˜ë³µ
            - ì—†ìœ¼ë©´ ìƒˆë¡œìš´ ë…¸ë“œë¥¼ rightì†ì„±ìœ¼ë¡œ ì¶”ê°€í•´ì¤Œ
        - ì‘ìœ¼ë©´
            - left ì†ì„±ì— ë…¸ë“œê°€ ìˆëŠ”ì§€ í™•ì¸
            - ìˆìœ¼ë©´ .leftë¡œ ë„˜ì–´ê°€ì„œì´ ê³¼ì •ì„ ë°˜ë³µ
            - ì—†ìœ¼ë©´ ìƒˆë¡œìš´ ë…¸ë“œë¥¼ leftì†ì„±ìœ¼ë¡œ ì¶”ê°€í•´ì¤Œ
- ëë‚˜ë©´ ì „ì²´ ì´ì§„íƒìƒ‰íŠ¸ë¦¬ ë°˜í™˜

```javascript
insert(value){
    const newNode = new Node(value);
    if(!this.root) {
      this.root = newNode;
      return this;
    }

    let current = this.root;
    while(true){
      if(value === current.value) return undefined;
      if(value < current.value) {
        if(!current.left){
          current.left = newNode;
          return this;
        }
        current = current.left;
      } else if(value > current.value) {
        if(!current.right) {
          current.right = newNode;
          return this;
        }
        current = current.right;
      }
    }
  }
```

## contains ë©”ì„œë“œ

í•´ë‹¹ ê°’ì„ ê°€ì§„ ë…¸ë“œê°€ íŠ¸ë¦¬ì— ìˆëŠ”ì§€ í™•ì¸

## Contains pseudo code

- ë£¨íŠ¸ì—ì„œ ì‹œì‘
    - ë£¨íŠ¸ ì—†ìœ¼ë©´ íƒìƒ‰ ë
    - ë£¨íŠ¸ ìˆê³  ì°¾ëŠ” ê°’ê³¼ ë™ì¼í•˜ë©´ return false
    - ë£¨íŠ¸ ìˆê³  ë£¨íŠ¸ì˜ ê°’ê³¼ ì°¾ëŠ”ê°’ì´ ë‹¤ë¥¼ë•Œ
        - ì°¾ëŠ” ê°’ì´ ë£¨íŠ¸ì˜ ê°’ ë³´ë‹¤ í¬ë©´ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™
        - ì‘ìœ¼ë©´ ì™¼ìª½ìœ¼ë¡œ ì´ë™
        - ì°¾ìœ¼ë©´ ë¦¬í„´ true
        - ëª»ì°¾ìœ¼ë©´ ìœ„ì˜ ì ˆì°¨ ë°˜ë³µ
        - ê·¸ë˜ë„ ì—†ìœ¼ë©´ return false

```javascript
contains (value){
	if(!this.root) return false;
	let current = this.root,
			found = false;

	while(current && !found){
		if(value < current.value){
			current = current.left;
		}else if(value > current.value){
			current = current.right;
		}else {
			return true;
		}
	}

	return false; 
}
```

## BIG O Of BST

- Insertion : O(log N)
- Searching: O(log N)
- Worst : í•œìª½ìœ¼ë¡œë§Œ ì ë ¤ìˆëŠ” ì—°ê²°ë¦¬ìŠ¤íŠ¸ ê°™ì€ ì´ì§„ê²€ìƒ‰íŠ¸ë¦¬ ê°™ì€ê²½ìš°ì—ëŠ” O(N)ì´ ê±¸ë¦¬ê¸° ë§ˆë ¨ì„(ê° ë ˆë²¨ë§ˆë‹¤ ì²˜ë¦¬í•˜ëŠ” ê°œìˆ˜ê°€ ì¤„ì–´ë“¤ ìˆ˜ê°€ ì—†ê¸° ë•Œë¬¸)
    - ë£¨íŠ¸ë¥¼ ì¬ ì •ë ¬í•˜ë©´ ê°€ëŠ¥í•´ì§€ê¸°ë„ í•˜ì§€ë§Œ ì´ëŸ°ê²½ìš°ì—ëŠ” ê·¸ëƒ¥ ë‹¤ë¥¸ ìë£Œêµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ëŠ”ê²ƒë„ ì¢‹ìŒ


# íŠ¸ë¦¬ìˆœíšŒ(Traversing A Tree)

í¬ê²Œ ë‘ê°€ì§€ ë°©ì‹ì´ ìˆìŒ

- Breadth-first Search(ë„ˆë¹„ ìš°ì„  íƒìƒ‰)
    - InOrder(ì •ìœ„ìˆœíšŒ) - ì•„ë˜ë¡œ ë‚´ë ¤ê°„ ë‹¤ìŒì— ì˜¬ë¼ì˜´
    - PreOrder(ì „ìœ„ ìˆœíšŒ) - ë£¨íŠ¸ë¶€í„° ë‚´ë ¤ê°
    - PostOrder(í›„ìœ„ ìˆœíšŒ) - ì•„ë˜ë¡œ ë‚´ë ¤ê°„ ë‹¤ìŒì— ê° ë ˆë²¨ ì²´ìš°ê³  ì˜¬ë¼ì˜´
- Depth-first Search(ê¹Šì´ ìš°ì„  íƒìƒ‰)

## BFS(ë„ˆë¹„ ìš°ì„  íƒìƒ‰)

ê°™ì€ ë ˆë²¨ì— ìˆëŠ” ë…¸ë“œ ìš°ì„  íƒìƒ‰ â†’ ìì‹ ë…¸ë“œë¥¼ ë³´ê¸°ì „ì— í˜•ì œë…¸ë“œë¥¼ ë¨¼ì € ë‹¤ ë³´ëŠ” ê²ƒ

### Steps

- ë°©ë¬¸í•œ ë…¸ë“œë“¤ì„ ë‹´ì„ íë¥¼ ë§Œë“¤ì–´ì„œ(ë°°ì—´ ì“°ë˜ ì§•) ë³€ìˆ˜ ì„ ì–¸
- í•¨ìˆ˜ ì¢…ë£Œ í›„ ë°˜í™˜í•  ë°©ë¬¸í•œ ìˆœì„œë¥¼ ê°€ì§ˆ visitedë³€ìˆ˜ë¥¼ ë§Œë“¤ì–´ì¤Œ
- ë£¨íŠ¸ë…¸ë“œë¥¼ íì— ë„£ì–´ì¤Œ
- íì— ë¬´ì–¸ê°€ê°€ ìˆë‹¤ë©´ ê³„ì† ë£¨í”„ë¥¼ ëŒë¦´ ê±°ì„
    - ê·¸ë¦¬ê³  íì—ì„œ dequeueë¥¼ í•¨. (ë°°ì—´ì¸ ê²½ìš° shift)
        - dequeueí•œ ë…¸ë“œë¥¼ visitedì— ì¶”ê°€í•´ì¤Œ
        - ê·¸ë¦¬ê³  í•´ë‹¹ ë…¸ë“œì— ì™¼ìª½ê°’ì´ ìˆëŠ”ì§€ í™•ì¸í•œ ë’¤ ìˆë‹¤ë©´ íì— ë„£ì–´ì¤Œ
        - ê·¸ë¦¬ê³  ì˜¤ë¥¸ìª½ê°’ ìˆëŠ”ì§€ í™•ì¸í•œ ë’¤ ìˆë‹¤ë©´ íì— ë„£ì–´ì¤Œ
    - ë£¨í”„ê°€ ëë‚œ ë‹¤ìŒ ëª¨ë“  ê°’ì„ ì €ì¥í•œ visitedë³€ìˆ˜ë¥¼ ì¶œë ¥
    

```jsx
BFS(){
	let data = [],
			queue = [],
			node = this.root;

	queue.push(this.root);
	
	while(queue.length){
		node = queue.shift();
		data.push(node.value);
		if(node.left) queue.push(node.left);
		if(node.right) queue.push(node.right);
	}
	return data;
}
```

## DFS(ê¹Šì´ ìš°ì„  íƒìƒ‰)

ëª¨ë“ ë…¸ë“œë¥¼ ë°©ë¬¸í•˜ê±°ë‚˜ ìˆœíšŒí• ë•Œ í˜•ì œ ë…¸ë“œë¡œ ë„˜ì–´ê°€ê¸° ì „ì— ìˆ˜ì§ìœ¼ë¡œ íŠ¸ë¦¬ì˜ ëê¹Œì§€ ë‚´ë ¤ê°(íŠ¸ë¦¬ì˜ ë§¨ì•„ë˜ì— ë„ë‹¬í• ë•Œê¹Œì§€ ë‚´ë ¤ê°)

## Pre-order(ì „ìœ„ íƒìƒ‰)

ë…¸ë“œë¥¼ ë°©ë¬¸í•˜ê³  ì™¼ìª½ ì „ì²´ ë…¸ë“œë¥¼ ë¨¼ì € ë°©ë¬¸í•˜ê³  ì˜¤ë¥¸ìª½ì„ ë°©ë¬¸í•˜ë©° ìˆœíšŒí•˜ëŠ” ê²ƒì„

### Steps

- ìˆœí™˜í˜•ìœ¼ë¡œ ë§Œë“œëŠ”ê±¸ ì¶”ì²œ(ì¬ê·€)
- ë°©ë¬¸í•  ë…¸ë“œê°’ì„ ë‹´ì„ ë°°ì—´ ë³€ìˆ˜ë¥¼ ì„ ì–¸
- rootë…¸ë“œë¥¼ ë°°ì—´ ë³€ìˆ˜ì— ë„£ìŒ
- helperí•¨ìˆ˜(traverse)ë¥¼ ë§Œë“¤ì–´ì„œ ë…¸ë“œ ì¸ìˆ˜ë¥¼ ì…ë ¥ë°›ì„ ê²ƒì„
    - ë…¸ë“œ ì¸ìˆ˜ì˜ ê°’ì„ ë°©ë¬¸í•  ë…¸ë“œê°’ì„ ë‹´ì„ ë°°ì—´ë³€ìˆ˜ì— ë‹´ìŒ
    - í•´ë‹¹ ë…¸ë“œ ì¸ìˆ˜ì˜ left ì†ì„±ì´ ìˆìœ¼ë©´ helperí•¨ìˆ˜ë¥¼ leftì†ì„±ì˜ ë…¸ë“œì™€ ê°™ì´ í˜¸ì¶œ
    - right ì†ì„±ì´ ìˆìœ¼ë©´ helperí•¨ìˆ˜ë¥¼ rightì†ì„±ì˜ ë…¸ë“œì™€ ê°™ì´ í˜¸ì¶œ
- helperí•¨ìˆ˜ë¥¼ current(ì²˜ìŒì€ ë£¨íŠ¸ê² ì§€)ì™€ í•¨ê»˜ í˜¸ì¶œ
- ë°©ë¬¸í•  ë…¸ë“œê°’ì„ ë‹´ì€ ë¦¬ìŠ¤íŠ¸ ë³€ìˆ˜ë¥¼ ë°˜í™˜

```jsx
DFSPreOrder(){
	const data = [];

	const traverse = (node) => {
		data.push(node.value);		
		if(node.left) traverse(node.left);
		if(node.right) traverse(node.right);
	}

	traverse(this.root);
	return data;
}
// [10, 6, 3, 8, 15, 20]
```

## Post-order(í›„ìœ„ íƒìƒ‰)

ì™¼ìª½ ë¨¼ì € ë‹¤ ë°©ë¬¸í•˜ê³  ì˜¤ë¥¸ìª½ ë‹¤ ë°©ë¬¸í•˜ê³  ë…¸ë“œ ë°©ë¬¸

### Steps

- ìˆœí™˜í˜•ìœ¼ë¡œ ë§Œë“œëŠ”ê±¸ ì¶”ì²œ(ì¬ê·€)
- ë°©ë¬¸í•  ë…¸ë“œê°’ì„ ë‹´ì„ ë°°ì—´ ë³€ìˆ˜ë¥¼ ì„ ì–¸
- rootë…¸ë“œë¥¼ ë°°ì—´ ë³€ìˆ˜ì— ë„£ìŒ
- preOrderí•¨ìˆ˜(helperí•¨ìˆ˜)ë¥¼ ë§Œë“¤ì–´ì„œ ë…¸ë“œ ì¸ìˆ˜ë¥¼ ì…ë ¥ë°›ì„ ê²ƒì„
    - í•´ë‹¹ ë…¸ë“œ ì¸ìˆ˜ì˜ left ì†ì„±ì´ ìˆìœ¼ë©´ helperí•¨ìˆ˜ë¥¼ leftì†ì„±ì˜ ë…¸ë“œì™€ ê°™ì´ í˜¸ì¶œ
    - right ì†ì„±ì´ ìˆìœ¼ë©´ helperí•¨ìˆ˜ë¥¼ rightì†ì„±ì˜ ë…¸ë“œì™€ ê°™ì´ í˜¸ì¶œ
    - ë…¸ë“œ ì¸ìˆ˜ì˜ ê°’ì„ ë°©ë¬¸í•  ë…¸ë“œê°’ì„ ë‹´ì„ ë°°ì—´ë³€ìˆ˜ì— ë‹´ìŒ
- helperí•¨ìˆ˜ë¥¼ current(ì²˜ìŒì€ ë£¨íŠ¸ê² ì§€)ì™€ í•¨ê»˜ í˜¸ì¶œ
- ë°©ë¬¸í•  ë…¸ë“œê°’ì„ ë‹´ì€ ë¦¬ìŠ¤íŠ¸ ë³€ìˆ˜ë¥¼ ë°˜í™˜

```jsx
DFSPostOrder (){
	const data = [];

	const traverse = (node) => {
		if(node.left) traverse(node.left);
		if(node.right) traverse(node.right);
		data.push(node.value);
	}
	traverse(this.root);
	return data;
} 

```

## In-order(ì¤‘ìœ„ íƒìƒ‰)

ì™¼ìª½ ë¨¼ì € ë‹¤ ë°©ë¬¸í•˜ê³  ë…¸ë“œ ë°©ë¬¸í•˜ê³  ì˜¤ë¥¸ìª½ ë°©ë¬¸

### Steps

- ìˆœí™˜í˜•ìœ¼ë¡œ ë§Œë“œëŠ”ê±¸ ì¶”ì²œ(ì¬ê·€)
- ë°©ë¬¸í•  ë…¸ë“œê°’ì„ ë‹´ì„ ë°°ì—´ ë³€ìˆ˜ë¥¼ ì„ ì–¸
- rootë…¸ë“œë¥¼ ë°°ì—´ ë³€ìˆ˜ì— ë„£ìŒ
- preOrderí•¨ìˆ˜(helperí•¨ìˆ˜)ë¥¼ ë§Œë“¤ì–´ì„œ ë…¸ë“œ ì¸ìˆ˜ë¥¼ ì…ë ¥ë°›ì„ ê²ƒì„
    - í•´ë‹¹ ë…¸ë“œ ì¸ìˆ˜ì˜ left ì†ì„±ì´ ìˆìœ¼ë©´ helperí•¨ìˆ˜ë¥¼ leftì†ì„±ì˜ ë…¸ë“œì™€ ê°™ì´ í˜¸ì¶œ
    - ë…¸ë“œ ì¸ìˆ˜ì˜ ê°’ì„ ë°©ë¬¸í•  ë…¸ë“œê°’ì„ ë‹´ì„ ë°°ì—´ë³€ìˆ˜ì— ë‹´ìŒ
    - right ì†ì„±ì´ ìˆìœ¼ë©´ helperí•¨ìˆ˜ë¥¼ rightì†ì„±ì˜ ë…¸ë“œì™€ ê°™ì´ í˜¸ì¶œ
- helperí•¨ìˆ˜ë¥¼ current(ì²˜ìŒì€ ë£¨íŠ¸ê² ì§€)ì™€ í•¨ê»˜ í˜¸ì¶œ
- ë°©ë¬¸í•  ë…¸ë“œê°’ì„ ë‹´ì€ ë¦¬ìŠ¤íŠ¸ ë³€ìˆ˜ë¥¼ ë°˜í™˜

```jsx
DFSInOrder (){
	const data = [];
	const traverse = (node) => {
		if(node.left) traverse(node.left);
		data.push(node.value);
		if(node.right) traverse(node.right);
	}
	traverse(this.root);
	return data;
}
```

## BFS ? DFS ì–¸ì œ ì‚¬ìš©?

T.CëŠ” ê¸°ë³¸ì ìœ¼ë¡œ BFS, DFSëª¨ë‘ ê°™ìŒ (ëª¨ë“  ë…¸ë“œë¥¼ ê²°êµ­ ë‹¤ ë°©ë¬¸í•˜ë¯€ë¡œ)

ê·¼ë° ê³µê°„ ë³µì¡ë„(S.C) ê°™ì€ê²½ìš° êµ‰ì¥íˆ ë ˆë²¨ì´ ë†’ì€(ê·¸ëŸ¬ë‹ˆê¹Œ ê¹Šì´ê°€ ê¹Šì€ íŠ¸ë¦¬)íŠ¸ë¦¬ ë¼ë©´ BFSì˜ ê²½ìš° Qì— ë™ì¼ë ˆë²¨ì˜ ë…¸ë“œë“¤ì„ ë‹¤ ì €ì¥í•´ë†“ì•„ì•¼ í•˜ëŠ”ë°, ë ˆë²¨ì´ ê¹Šì–´ì§€ë©´ ì§ˆ ìˆ˜ë¡ ì €ì¥í•´ì•¼ í•  ë…¸ë“œë“¤ì´ ë§ì•„ì§(ê²°êµ­ ì‚¬ë¼ì§€ê² ì§€ë§Œ). ê·¸ë˜ì„œ ê³µê°„ ë³µì¡ë„ê°€ ì»¤ì§€ê²Œ ë¨

ë°˜ëŒ€ë¡œ DFSë¥¼ í•˜ê²Œ ë˜ë©´ ì½œìŠ¤íƒì— ê° ê¹Šì´ì˜ í•˜ë‚˜ì”©ì˜ ë…¸ë“œë§Œ ì €ì¥í•˜ë©´ ë¨.

ê²°ë¡ ì€ ê¹Šì´ë³´ë‹¤ ë„“ì´ê°€ í° íŠ¸ë¦¬ì˜ ê²½ìš°ì—ëŠ” ê¹Šì´ ìš°ì„ íƒìƒ‰ì´ ë” ì ì€ ê³µê°„ì„ ì ìœ í•˜ê²Œ ë¨

### íƒìƒ‰ì˜ ë‹¤ë¥¸ì¢…ë¥˜ëŠ” ì–¸ì œì“°ëƒ(ì „ìœ„,ì¤‘ìœ„,í›„ì˜)

ì´ì§„ íƒìƒ‰íŠ¸ë¦¬ë¼ê³  ê°€ì •

ì´ì§„ íƒìƒ‰íŠ¸ë¦¬ì—ì„œ InOrder(ì¤‘ìœ„ íƒìƒ‰)ì„ í•˜ê²Œ ë˜ë©´ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ê°’ì´ ë‚˜ì˜¤ê²Œ ë  ê²ƒì„

PreOrder(ì „ìœ„íƒìƒ‰)ì˜ ê²½ìš° íŠ¸ë¦¬ë¥¼ ë³µì‚¬í•˜ê±°ë‚˜ í‰íƒ„í™”í•´ì„œ ì €ì¥í•˜ê³  ì‹¶ì€ ê²½ìš° ì‚¬ìš©í• ë§Œ í•¨

## Recap Of Tree

- íŠ¸ë¦¬ëŠ” ë¹„ì„ í˜•êµ¬ì¡°ê³  ë£¨íŠ¸ì™€ ìì‹ë…¸ë“œë¥¼ ê°€ì§ ğŸ™‚
- ì´ì§„ íŠ¸ë¦¬ëŠ” ì–´ë–¤íƒ€ì…ì˜ ê°’ì´ë“  ë‹¤ ê°€ì§ˆ ìˆ˜ ìˆìœ¼ë©´ ìµœâ€™ëŒ€â€™ ë‘ê°œì˜ ìì‹ì„ ê°€ì§
- ì´ì§„ â€˜íƒìƒ‰â€™íŠ¸ë¦¬ëŠ” ì´ì§„íŠ¸ë¦¬ì˜ íŠ¹ì • ë²„ì „ì´ë©° ì™¼ìª½ ìì‹ ë…¸ë“œê°€ ë¶€ëª¨ë…¸ë“œë³´ë‹¤ ì‘ê³  ì˜¤ë¥¸ìª½ ìì‹ë…¸ë“œê°€ ë¶€ëª¨ë…¸ë“œë³´ë‹¤ í° ê²½ìš° ì„ã…‡

# Tree Traverse Sample

```jsx
class Node {
	constructor(value){
		this.value = value;
		this.left = null;
		this.right = null;
	}
}

class BinarySearchTree {
	constructor(){
		this.root = null;
	}

	insert(value){
			const newNode = new Node(value);
			if(!this.root) {
				this.root = newNode;
				return this;
			}

			let current = this.root;
			while(true){
				if(value < current.value) {
					if(!current.left){
						current.left = newNode;
						return this;
					}
					current = current.left;
				} else if(value > current.value) {
					if(!current.right) {
						current.right = newNode;
						return this;
					}
					current = current.right;
				} else {
					return undefined;
				}
			}
	}

	contains (value){
		if(!this.root) return false;
		let current = this.root,
				found = false;

		while(current && !found){
			if(value < current.value){
				current = current.left;
			}else if(value > current.value){
				current = current.right;
			}else {
				return true;
			}
		}

		return false; 
	}

	BFS(){
		let data = [],
				queue = [],
				node = this.root;
	
		queue.push(this.root);
		
		while(queue.length){
			node = queue.shift();
			data.push(node.value);
			if(node.left) queue.push(node.left);
			if(node.right) queue.push(node.right);
		}
		return data;
	}

	DFSPreOrder(){
	const data = [];

	const traverse = (node) => {
		data.push(node.value);		
		if(node.left) traverse(node.left);
		if(node.right) traverse(node.right);
	}

	traverse(this.root);
	return data;
	}

	DFSPostOrder (){
		const data = [];
	
		const traverse = (node) => {
			if(node.left) traverse(node.left);
			if(node.right) traverse(node.right);
			data.push(node.value);
		}
		traverse(this.root);
		return data;
	} 

	DFSInOrder (){
	const data = [];
	const traverse = (node) => {
		if(node.left) traverse(node.left);
		data.push(node.value);
		if(node.right) traverse(node.right);
	}
	traverse(this.root);
	return data;
}

}

const tree = new BinarySearchTree();
tree.insert(10);
tree.insert(6);
tree.insert(15);
tree.insert(3);
tree.insert(8);
tree.insert(20);

//     10
//   6   15
// 3  8    20
tree.DFSPreOrder(); // [10, 6, 3, 8, 15, 20]
tree.DFSPostOrder(); // [3,8,6,20,15,10]
tree.DFSInOrder(); // [3,6,8,10,15,20]
```


# Binary Heap(ì´ì§„í™)

ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì™€ êµ‰ì¥íˆ ìœ ì‚¬í•¨

## ìµœëŒ€ ì´ì§„í™

- ë¶€ëª¨ë…¸ë“œê°€ í•­ìƒ ìì‹ë…¸ë“œë³´ë‹¤ í° ê°’ì„ ê°€ì§
- ì™¼ìª½ ì˜¤ë¥¸ìª½ ìƒê´€ì—†ì´ í•œë ˆë²¨ ì•„ë˜ ìˆëŠ” ìì‹ ë…¸ë“œëŠ” ë¶€ëª¨ë…¸ë“œë³´ë‹¤ ê°’ì´ ì‘ì•„ì•¼í•¨
- ì™¼ìª½ ì˜¤ë¥¸ìª½ ìˆœì„œê°€ ì—†ìŒ ê·¸ëƒ¥ ë¶€ëª¨ë…¸ë“œë³´ë‹¤ ìì‹ë…¸ë“œê°€ ì‘ìœ¼ë©´ ë¨

### ì¡°ê±´

- ê° ë¶€ëª¨ë…¸ë“œëŠ” ìµœëŒ€ ë‘ê°œì˜ ìì‹ ë…¸ë“œë¥¼ ê°€ì§
- ë¶€ëª¨ë…¸ë“œì˜ ê°’ì´ ì–¸ì œë‚˜ ë” í¼
- í˜•ì œ ë…¸ë“œ ì‚¬ì´ì—ì„œëŠ” ëŒ€ì†Œì˜ ì¡°ê±´ ì´ ì—†ìŒ(íŠ¹ë³„í•œ ìˆœì„œê°€ ì—†ìŒ)
- ì´ì§„í™ì€ ê°€ëŠ¥í•œí•œ ê°„ë‹¨í•´ì•¼í•¨. ë¶€ëª¨ë…¸ë“œì™€ ìì‹ë…¸ë“œì˜ ëŒ€ì†Œê´€ê³„ë§Œ ë‹¤ë£¨ê¸°ì— ì¶”ê°€ ë  ë•Œë§ˆë‹¤ ìì‹ë…¸ë“œê°€ ê°€ë“ ì°° ê²ƒ ì„(ì´ì§„íƒìƒ‰íŠ¸ë¦¬ì˜ ì¢Œìš° ëŒ€ì†Œê´€ê³„ë¥¼ ë”°ì§€ê¸°ì— ìì‹ë…¸ë“œê°€ ë¹„ì–´ìˆìŒì—ë„ ë‹¤ë¥¸ ë¶€ëª¨ë…¸ë“œ ë°‘ì— ìì‹ë…¸ë“œê°€ ìƒê¸°ëŠ” ê²½ìš°ê°€ ë°œìƒí•  ìˆ˜ ìˆìœ¼ë‹ˆê¹Œ ì´ê±¸ ë§í•˜ëŠ” ë“¯)
- ì™¼ìª½ë¶€í„° ì¶”ê°€í•´ì•¼í•¨

## ìµœì†Œ ì´ì§„ í™

- ìµœëŒ€ ì´ì§„í™ê³¼ ë°˜ëŒ€ì˜ ì¡°ê±´ ìƒê°í•˜ë©´ ë¨

## í™ì´ ì™œ í•„ìš”í•œê°€

- ì´ì§„ í™ì€ ìš°ì„ ìˆœìœ„ íë¥¼ ë§Œë“¤ê¸° ìœ„í•´ ìì£¼ ì‚¬ìš© ë¨.
    
    ìš”ì†Œë¥¼ ì¶”ê°€ ì œê±°í•˜ë©´ì„œ ìš°ì„ ìˆœìœ„ë¥¼ ì¶”ì í•˜ê¸° ìœ„í•´ì„œ ìš°ì„ ìˆœìœ„ íê°€ ì‚¬ìš© ë¨. ê° ìš”ì†Œì— ëŒ€í•´ ì¤‘ìš”í•œ ì •ë„ë¥¼ ë¶€ì—¬í•´ì„œ ì¤‘ìš”í•œ ì •ë„ì— ë”°ë¼ íì•ˆì˜ ì ì ˆí•œ ì¥ì†Œì— ë°°ì¹˜í•˜ëŠ” ê²ƒ ì„.
    
- ê·¸ë˜í”„ íƒìƒ‰ì—ì„œë„ í™ì€ ë³´ì¡°ìš©ë„ë¡œ ë§ì´ ì‚¬ìš©ë˜ê³¤ í•¨

### ë°°ì—´ì—ì„œ í™ ìì‹ ì°¾ê¸°

ì œì¼ ë¶€ëª¨ ë…¸ë“œ, ì™¼ìª½ ìì‹, ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œ ìˆœìœ¼ë¡œ ë°°ì—´ì— ë„£ëŠ”ë‹¤ê³  ê°€ì •í–ˆì„ ë•Œ

ì™¼ìª½ ìì‹ ë…¸ë“œ: 2* ë¶€ëª¨ì¸ë±ìŠ¤ + 1, 

ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œ: 2* ë¶€ëª¨ì¸ë±ìŠ¤ + 2

ì´ëŸ¬ë©´ ì´ì œ íŠ¹ì • ì¸ë±ìŠ¤ë¥¼ í†µí•´ ë¶€ëª¨ ì¸ë±ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ìˆê²Œ ë¨

ë¶€ëª¨ì¸ë±ìŠ¤ : Math.floor((íŠ¹ì •ì¸ë±ìŠ¤ - 1)/2);

- 0.5ë‹¨ìœ„ ì¸ë±ìŠ¤ëŠ” ì—†ìœ¼ë‹ˆê¹Œ :)

### Max Heap Skeleton

```jsx
class MaxBinaryHeap {
	constructor(){
		this.values = [];
	}
}
```

### Insert

- ë§ˆì§€ë§‰ì— ë„£ê³ 
- Bubble UP(ë¶€ëª¨ë…¸ë“œì™€ ì‚½ì…í•œ ë…¸ë“œ ìœ„ì¹˜ë¥¼ ë°”ê¿ˆ)ì„ í†µí•´ì„œ ê°’ì— ì•Œë§ëŠ” ì ì ˆí•œ ìœ„ì¹˜ë¥¼ ì°¾ì„ ë•Œ ê¹Œì§€ ìœ„ë¡œ ì´ë™ ì‹œí‚´

### Insert pseudo code

- ë°°ì—´ì˜ ëì— ê°’ì„ ì¶”ê°€
- Bubble up
    - ë§ˆì§€ë§‰ì— ë„£ì€ ê°’ì˜ ë¶€ëª¨ë¥¼ ì°¾ì•„ë´„
    - ë¶€ëª¨ ì¸ë±ìŠ¤ì˜ ê°’ê³¼ í•´ë‹¹ ì¸ë±ìŠ¤ì˜ ê°’ì„ ë¹„êµí•¨
        - ì¶”ê°€í•œ ê°’ì´ ë” í¬ë©´ ê°’ì„ ë°”ê¿ˆ
            - ë°”ê¾¸ê³  ë‚œ ë’¤ ë¶€ëª¨ì¸ë±ìŠ¤ ê°’ì„ ë‹¤ì‹œ ì„¤ì •í•´ ì¤Œ
        - ì•„ë‹ˆë©´ ë
        

```jsx
bubbleUp() {
	let idx =	this.values.length - 1;
	const element = this.values[idx];
	while(idx > 0){
		let parentIdx = Math.floor((idx-1)/2);
		let parent = this.values[parentIdx];
		
		if(element <= parent) break;

		this.values[parentIdx] = element;
		this.values[idx]  = parent;
		idx = parentIdx;
	}	
}

insert(element) {
	this.values.push(element);
	this.bubbleUp();
}
/*
[41,39,33,18,27,12,55]
 0   1  2  3  4  5 new
*/
```

### Removing from a Binary Heap(Extract Max)

- ë£¨íŠ¸ë¥¼ ì œê±°í•¨
- ìµœê·¼ ì¶”ê°€ëœ(ì•„ë§ˆ ì œì¼ ë°‘ì— ìˆì„) ë…¸ë“œë¥¼ ë£¨íŠ¸ ìœ„ì¹˜ë¡œ ëŒì–´ì˜¬ë¦¼
- ìµœëŒ€ ë˜ëŠ” ìµœì†Œ ì´ì§„ í™ ë“±ì˜ ì¡°ê±´ì— ë§ë„ë¡ ì¡°ì •ì„ í•´ì¤Œ(Sink Down)

### Removing from Binary Heap(Extract Max) pseudo code

- ë¦¬ìŠ¤íŠ¸ì—ì„œ popì‹œì¼œì„œ ì œê±°í•  ê°’ì„ ë¦¬í„´ ì‹œì¼œì¤Œ
- ì²«ì§¸ ê°’ì„ ë§ˆì§€ë§‰ê°’ì´ë‘ ìœ„ì¹˜ë¥¼ ë°”ê¿ˆ
- sinkdown
    - ë¶€ëª¨ ì¸ë±ìŠ¤ëŠ” 0 ë¶€í„°ì‹œì‘(root)
    - ì™¼ìª½ ìì‹ ì¸ë±ìŠ¤: 2* ë¶€ëª¨ì¸ë±ìŠ¤  + 1
    - ì˜¤ë¥¸ìª½ ìì‹ ì¸ë±ìŠ¤: 2* ë¶€ëª¨ì¸ë±ìŠ¤  + 2
    - ì™¼ìª½ ë˜ëŠ” ì˜¤ë¥¸ìª½ ìì‹ì´ ë¶€ëª¨ë³´ë‹¤ í¬ë©´ ë¶€ëª¨ì™€ ìì‹ ìœ„ì¹˜ë¥¼ ë°”ê¿ˆ
        - ë‘˜ë‹¤ í´ë•ŒëŠ” ë” í°ìª½ê³¼ ë³€ê²½
        - ë¶€ëª¨ì¸ë±ìŠ¤ë¥¼ ë°”ë€ ìì‹ ì¸ë±ìŠ¤ë¡œ ì—…ë°ì´íŠ¸ í•´ì£¼ê³ 
        - ì´ ê³¼ì •ì„ ë‘ ìì‹ì´ ë¶€ëª¨ë³´ë‹¤ ì‘ì„ ë•Œ ê¹Œì§€ ë°˜ë³µ
        - rootë¥¼ ë°˜í™˜

```jsx
sinkDown(){
	let idx = 0;
	const length = this.values.length;
	const element = this.values[0];

	while(true){
		let leftChildIdx = 2 * idx + 1,
		rightChildIdx = 2 * idx + 2;
		let leftChild, rightChild;
		let swap = null;
		
		if(leftChildIdx < length){
			leftChild = this.values[leftChildIdx];
			if(leftChild > element){
				swap = leftChildIdx;
			}
		}

		if(rightChildIdx < length){
			rightChild = this.values[rightChildIdx];
			if((swap === null && rightChild > element) ||
				 (swap !== null && rightChild > leftChild)) {
				swap = rightChildIdx;
			}
		}
		if(swap === null) break;
		this.values[idx] = this.values[swap];
		this.values[swap] = element;
		idx = swap;
	}	
}

extractMax(){
	const max = this.values[0];
	const end = this.values.pop();
	if(this.values.length > 0) {
		this.values[0] = end;
		this.sinkDown();		
	}
	return max;
}
```

### ìµœëŒ€ ì´ì§„ í™ Summary

```jsx
class MaxBinaryHeap {
	constructor(){
		this.values = [];
	}

	bubbleUp() {
		let idx =	this.values.length - 1;
		const element = this.values[idx];
		while(idx > 0){
			let parentIdx = Math.floor((idx-1)/2);
			let parent = this.values[parentIdx];
			
			if(element <= parent) break;
	
			this.values[parentIdx] = element;
			this.values[idx]  = parent;
			idx = parentIdx;
		}	
	}
	
	insert(element) {
		this.values.push(element);
		this.bubbleUp();
	}

	sinkDown(){
		let idx = 0;
		const length = this.values.length;
		const element = this.values[0];
	
		while(true){
			let leftChildIdx = 2 * idx + 1,
			rightChildIdx = 2 * idx + 2;
			let leftChild, rightChild;
			let swap = null;
			
			if(leftChildIdx < length){
				leftChild = this.values[leftChildIdx];
				if(leftChild > element){
					swap = leftChildIdx;
				}
			}
	
			if(rightChildIdx < length){
				rightChild = this.values[rightChildIdx];
				if((swap === null && rightChild > element) ||
					 (swap !== null && rightChild > leftChild)) {
					swap = rightChildIdx;
				}
			}
			if(swap === null) break;
			this.values[idx] = this.values[swap];
			this.values[swap] = element;
			idx = swap;
		}	
	}
	
	
	extractMax(){
		const max = this.values[0];
		const end = this.values.pop();
		if(this.values.length > 0) {
			this.values[0] = end;
			this.sinkDown();		
		}
		return max;
	}
}
const maxHeap = new MaxBinaryHeap();
maxHeap.insert(55);
maxHeap.insert(44);
maxHeap.insert(77);
maxHeap.insert(1);
maxHeap.insert(100);
maxHeap.values //[ 100, 77, 55, 1, 44 ]
maxHeap.extractMax() // 100
maxHeap.extractMax() // 77
```

## ìš°ì„ ìˆœìœ„ í (Priority Queue)

- ê° ìš”ì†Œê°€ ê·¸ì— í•´ë‹¹í•˜ëŠ” ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§€ëŠ” ë°ì´í„° êµ¬ì¡°
- ë” ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§„ ìš”ì†Œê°€ ë” ë‚®ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§„ ìš”ì†Œë³´ë‹¤ ë¨¼ì € ì²˜ë¦¬ ë¨.
- ìš°ì„ ìˆœìœ„ íì™€ í™ì€ ë³„ê°œì„.ìš°ì„ ìˆœìœ„ íëŠ” ì¶”ìƒì  ê°œë…ì´ê³  í™ë§Œì´ ì•„ë‹ˆë¼ ë¦¬ìŠ¤íŠ¸ë‚˜ ë°°ì—´ë¡œë„ ë§Œë“¤ìˆ˜ëŠ” ìˆìŒ
    - ë‹¨ì§€ ë¦¬ìŠ¤íŠ¸ë‚˜ ë°°ì—´ì¸ ê²½ìš° íšŒë¬¸ ì „ì²´ë¥¼ ëŒì•„ ìš°ì„ ìˆœìœ„ë¥¼ íŒŒì•…í•´ì¤˜ì•¼í•˜ë¯€ë¡œ ë¹„íš¨ìœ¨ì ì¼ ë¿
        - ìš°ì„ ìˆœìœ„ íŒŒì•…(íƒìƒ‰)ì— O(N)ì´ë‚˜ ê±¸ë¦¼
            - ë°°ì—´ ì œê±°ë¥¼ ê°€ì •í•˜ë©´ ì œê±°ì—ë„ ìµœì•…ì˜ ê²½ìš° O(N)ì´ ê±¸ë¦´ ìˆ˜ë„ ìˆìŒ(ì¸ë±ìŠ¤ ë‹¤ì‹œ ì¬ì •ë ¬í•´ì•¼í•˜ë‹ˆê¹Œ)
    - í™ì€ ì‚½ì…ê³¼ ì œê±° ëª¨ë‘ O(N)ì„ ê°€ì§€ê¸°ì— êµ‰ì¥íˆ ì¢‹ìŒ

### ìš°ì„ ìˆœìœ„ íëŠ” ì–´ë””ì— ì“°ì´ë ¤ë‚˜

ì»´í“¨í„°ì˜ í”„ë¡œì„¸ìŠ¤ë¥¼ ìƒê°í•´ë³´ì

ì»´í“¨í„° ì‹¤í–‰ ì‹œ ì—¬ëŸ¬ê°€ì§€ í”„ë¡œì„¸ìŠ¤ê°€ ëŒì•„ê°€ëŠ”ë° ì—¬ê¸°ì„œ ìš°ì„ ìˆœìœ„ê°€ ìˆëŠ” ê²ƒì´ ë¨¼ì € ëŒì•„ê°€ê²Œ ë˜ëŠ” ê²ƒ(unix ì˜ niceë¥¼ ìƒê°í•˜ë©´ ë¨)

```jsx
class Node {
	constructor(val){
		this.val = val;
		this.priority = null;
	}
}

class PriorityQueue {
	constructor(){
		this.values = [];
	}	
}
```

ìµœëŒ€ ì´ì§„í™ì´ ì•„ë‹Œ ìµœì†Œì´ì§„í™(ë‚®ì€ ìˆ«ìê°€ ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§€ëŠ” í˜„ìƒì„ ë§Œë“¤ì–´ë³´ê¸° ìœ„í•´)ì„ ì‚¬ìš©í•´ì„œ ìš°ì„ ìˆœìœ„ íë¥¼ êµ¬í˜„í•´ ë³¼ ê²ƒ.

### ìš°ì„ ìˆœìœ„ í pseudo code

- ìµœì†Œ ì´ì§„í™ì„ ì‚¬ìš© - ë‚®ì€ ìˆ«ìê°€ ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§
- ê° ë…¸ë“œëŠ” val, priority ì†ì„±ì„ ê°€ì§. priority ì†ì„±ì„ í†µí•´ í™ì„ êµ¬ì„±í•  ê²ƒì„
- Enqueue ë©”ì„œë“œëŠ” ê°’ì„ ì¸ìë¡œ ë°›ê³  ìƒˆë¡œìš´ ë…¸ë“œë¥¼ í™ì— ì¶”ê°€í•œ ë‹¤ìŒ ìµœì†Œì´ì§„í™ì— ë§ê²Œ ì •ë ¬ì„ í•  ê²ƒì„
- Dequeue ë©”ì„œë“œëŠ” root elementë¥¼ ì œê±°í•˜ê³  ì œê±°í•œ ìš”ì†Œë¥¼ ë°˜í™˜í•  ê²ƒì´ë©° ìµœì†Œì´ì§„í™ì„ í™ì„ ìš°ì„ ìˆœìœ„ì— ë§ê²Œ ì •ë ¬í•  ê²ƒì„

```jsx
class Node {
	constructor(val, priority){
		this.val = val;
		this.priority = priority;
	}
}

class PriorityQueue {
	constructor(){
		this.values = [];
	}	

	bubbleUp() {
	let idx =	this.values.length - 1;
	const element = this.values[idx];
	while(idx > 0){
		let parentIdx = Math.floor((idx-1)/2);
		let parent = this.values[parentIdx];
		
		if(element.priority >= parent.priority) break;

		this.values[parentIdx] = element;
		this.values[idx]  = parent;
		idx = parentIdx;
	}	
	}

	sinkDown(){
		let idx = 0;
		const length = this.values.length;
		const element = this.values[0];
	
		while(true){
			let leftChildIdx = 2 * idx + 1,
			rightChildIdx = 2 * idx + 2;
			let leftChild, rightChild;
			let swap = null;
			
			if(leftChildIdx < length){
				leftChild = this.values[leftChildIdx];
				if(leftChild.priority < element.priority){
					swap = leftChildIdx;
				}
			}
	
			if(rightChildIdx < length){
				rightChild = this.values[rightChildIdx];
				if((swap === null && rightChild.priority < element.priority) ||
					 (swap !== null && rightChild.priority < leftChild.priority)) {
					swap = rightChildIdx;
				}
			}
			if(swap === null) break;
			this.values[idx] = this.values[swap];
			this.values[swap] = element;
			idx = swap;
		}	
	}

	enqueue(val, priority) {
		let newNode = new Node(val, priority);
		this.values.push(newNode);
		this.bubbleUp();
	}
	
	dequeue(){
		const min = this.values[0];
		const end = this.values.pop();
		if(this.values.length > 0) {
			this.values[0] = end;
			this.sinkDown();		
		}
		return min;
	}
}

let ER = new PriorityQueue();
ER.enqueue("common cold", 5);
ER.enqueue("gunshot wound", 1);
ER.enqueue("high fever", 4);
ER.enqueue("broken arm", 2);
ER.enqueue("glass in foot", 3);
ER.dequeue(); // gunshot wound
ER.dequeue(); // broken arm
/*
ìš°ì„ ìˆœìœ„íì˜ ì‚½ì…ê³¼ ì œê±°ëŠ” O(LogN)ì„ ë”°ë¥´ê²Œ ë¨(íŠ¸ë¦¬ì–ì—¬)
*/
```

### ì´ì§„ í™ì˜ Big O

ì´ì§„í™ì€ ì‚½ì…ê³¼ ì‚­ì œ ì„±ëŠ¥ ì¢‹ìŒ ã…ã……ã…

ì´ì§„ í™ êµ¬ì¡°ë¥¼ ìƒê°í•´ë³´ë©´ ë ˆë²¨ì„ ë‚´ë ¤ê°ˆë•Œë§ˆë‹¤ 2ë°°ì˜ ë…¸ë“œê°€ ìƒê¸°ëŠ” ê²ƒì„

ì´ì§„í™ì€ ì™¼ìª½ë¶€í„° ëª¨ë“  ê±¸ ì±„ìš°ê³  ë‹¤ ì±„ì›Œì•¼ ë‹¤ìŒë ˆë²¨ë¡œ ë„˜ì–´ê°.

ì •ë ¬ ì‹œ ê° ë ˆë²¨ì˜ ë¶€ëª¨ë…¸ë“œì™€ë§Œ ê°’ì„ ë¹„êµí•˜ê¸° ë•Œë¬¸ì— ë ˆë²¨ë§Œí¼ë§Œ ë¹„êµí•˜ê²Œ ë˜ëŠ” ê²ƒì„

ì‚½ì…ê³¼ ì œê±°ë§Œ í•˜ëŠ” ê²ƒì€ O(1)ì„ ê°€ì§€ê²Œ ë˜ê³  ë‚˜ë¨¸ì§€ëŠ” ì •ë ¬ì´ë‹ˆ O(LogN)ì´ ë˜ëŠ” ê²ƒ

ê·¸ë˜ì„œ ì •í™•íˆ 2ë¥¼ ë°‘ìœ¼ë¡œ ê°€ì§€ëŠ” Logê°€ ë˜ëŠ” ê²ƒ.

ì´ì§„ íƒìƒ‰íŠ¸ë¦¬ì™€ ë¹„êµ ì‹œ ì´ì§„íƒìƒ‰íŠ¸ë¦¬ëŠ” ìˆ˜í‹€ë¦¬ë©´ ë‹¨ì¼ì—°ê²°ë¦¬ìŠ¤íŠ¸ì™€ ê°™ì€ ëª¨ì–‘ì´ ë‚˜ì˜¬ ìˆ˜ë„ ìˆê²Œ ë˜ì–´ worstì¼€ì´ìŠ¤ë¡œ ëª¨ë‘ ë¹„êµí•´ì•¼í•˜ëŠ” ê²½ìš°ê°€ ìƒê¸°ì§€ë§Œ ì´ì§„ í™ì€ ì–´ì¨Œë“  ì™¼ìª½ë¶€í„° ë‹¤ ì±„ì›Œì•¼í•˜ë¯€ë¡œ ê·¸ëŸ° ê²½ìš°ê°€ ìƒê¸¸ ìˆ˜ ì—†ìŒ.

íƒìƒ‰ì˜ ê²½ìš° ê° í˜•ì œë…¸ë“œë“¤ ë¼ë¦¬ ìš°ì„ ìˆœìœ„ê°€ ì—†ê¸°ì— í™•ì‹¤íˆ ì°¾ì„ ë•Œ ì „ì²´ë¥¼ ë‹¤ ë´ì•¼í•  ìˆ˜ë„ ìˆìŒ.

- Insertion: O(LogN)
- Removal: O(LogN)
- Search: O(N)

# Hash(í•´ì‹œ)

- í•´ì‹œí…Œì´ë¸”ì€ í‚¤-ê°’ ì˜ ìŒì„ ì €ì¥í•˜ëŠ” ë° ì‚¬ìš© ë¨
- í•´ì‹œí…Œì´ë¸”ì˜ í‚¤ëŠ” ë”°ë¡œ ì¸ë±ìŠ¤ë¥¼ ê°€ì§€ì§€ ì•ŠìŒ(ìˆœì„œê°€ ì—†ë‹¤ëŠ” ê²ƒì„)
- ë°°ì—´ê³¼ ë‹¤ë¥´ê²Œ ê°’ì°¾ê¸°, ì¶”ê°€, ì œê±°ê°€ ëª¨ë‘ ë°°ì—´ë³´ë‹¤ ë¹ ë¦„!!

## Hash function

- í•´ì‹œí•¨ìˆ˜ëŠ” ìˆ˜ì²œ,ìˆ˜ë°±ë§Œ ìë“  ì„ì˜ì˜ í¬ê¸°ë¥¼ ê°€ì§€ëŠ” ë°ì´í„°ë¥¼ ì…ë ¥í•˜ë©´ ì •í•´ì§„ í¬ê¸°ì˜ ë°ì´í„°ë¥¼ ì¶œë ¥í•˜ëŠ” í•¨ìˆ˜ì„ (ì…ë ¥ê°’ì„ ì¸¡ëŸ‰í•´ì„œ ì •í•´ì§„ ìˆ˜ë§Œí¼ì˜ ë°ì´í„°ë¥¼ ë°˜í™˜)

### Good Hash functions condition

- ë¹¨ë¼ì•¼í•¨(ìƒìˆ˜ì‹œê°„ì´ë©´ ë” ì¢‹ìŒ)
- ë°°ì—´ë‚´ì— ì¼ê´€ëœ ë°©ì‹ìœ¼ë¡œ ë¶„ë°°ë¥¼ í•´ì„œ ë‹¤ë¥¸ ê²ƒë“¤ê³¼ ê²¹ì¹˜ì§€ ì•Šê²Œ í•´ì•¼í•¨
- ê²°ì •ë¡ ì ì´ì–´ì•¼í•¨(Always same input and same output)

## í•´ì‹œí•¨ìˆ˜ ë§Œë“¤ì–´ë³´ê¸°

- ë¬¸ìì—´ë§Œ ê³ ë ¤í•´ì„œ ë¬¸ì œì„
- ë‹¤ë¥¸ ê°’ì„ ë„£ì–´ë„ ê°™ì€ ê°’ì´ ë‚˜ì˜¬ ìˆ˜ë„ ìˆëŠ”ê²Œ ë¬¸ì œì„(pink,10), (blue,10);
    - ëœë¤ì„±ì´ ìƒê¹€ ì´ëŸ¬ë©´ ê°™ì€ ê°’ ë‚˜ì˜¨ê²Œ ë°°ì—´ì— ë˜‘ê°™ì´ ë“¤ì–´ê°€ë²„ë¦¬ë‹ˆê¹Œ ê²¹ì³ì§€ë¯€ë¡œ ..
- ìƒìˆ˜ì‹œê°„ì´ ì•„ë‹˜ ( ë¬¸ìì—´ ë‹¤ ìˆœíšŒ í•˜ë¯€ë¡œ O(N)ì´ ë¨)

```jsx
const hash = (key, arrayLen) => {
	let total = 0;
	for(let char of key){
		//ì•ŒíŒŒë²³ ìˆœì„œ ë§Œë“¤ê¸°
		let value = char.charCodeAt(0)-96;
		total = (total+value) % arrayLen;
	}
	return total;
}
```

### í•´ì‹œ í•¨ìˆ˜ ë¬¸ì œì  ê°œì„ í•´ë³´ê¸°

- ìƒìˆ˜ì‹œê°„ ê°œì„ ì„ ìœ„í•´ Math.minì„ ì´ìš©í•´ì„œ 100ê¸€ìê°€ ë„˜ëŠ” ê¸€ìì—ì„œë„ ê± 100ê¸€ìë¡œ ê³ ì •ì„ ì‹œì¼œë²„ë¦¼(ìƒìˆ˜ì‹œê°„ ê°€ëŠ¥)
- í•´ì‹œ í•¨ìˆ˜ëŠ” ëŒ€ë¶€ë¶„ ì†Œìˆ˜ë¥¼ ì‚¬ìš©í•¨
    - ê°€ëŠ¥í•œ ë°ì´í„°ë¥¼ í¼ì³ë†“ê³  ë‹¤ì‹œ ë¹¨ë¦¬ ê°€ì ¸ì˜¤ê³  ì‹¶ì–´ì„œ ì†Œìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ìµœëŒ€í•œ í¼ì¹˜ëŠ” ê²ƒì´ë¼ê³  í•¨..
        - ì†Œìˆ˜ëŠ” ìê¸°ìì‹ ê³¼ ê·¸ ìˆ˜ ë§ê³ ëŠ” ì•ˆë‚˜ëˆ ì§€ë‹ˆ ì¶©ëŒ í™•ë¥ ì´ ì ë‹¤ë‚˜ ë­ë˜ë‚˜ ê·¸ë ‡ë‹¤í•¨

```jsx
const hash = (key, arrayLen) => {
	let total = 0;
	let WEIRD_PRIME = 31;
	for(let i = 0; i < Math.min(key.length, 100); i++){
		let char = key[i];
		let value = char.charCodeAt(0) - 96;
		total = (total * WEIRD_PRIME + value) % arrayLen;
	}
	return total;
}
```

### ì¶©ëŒë¬¸ì œë¥¼ í•´ê²°í•´ë³´ì

- Seperate chaining(ê°œë³„ ì²´ì´ë‹)
    - ê°™ì€ ì¥ì†Œì— ì—¬ëŸ¬ ë°ì´í„°ë¥¼ ì €ì¥í• ë•Œ ë°°ì—´ì´ë‚˜ ì—°ê²°ë¦¬ìŠ¤íŠ¸ ê°™ì€ ë‹¤ë¥¸ ìë£Œêµ¬ì¡°ë¥¼ ì–¹ì–´ì„œ ë°ì´í„° ì „ì²´ë¥¼ ì €ì¥í•  ë°°ì—´ì˜ í•´ë‹¹ ì¸ë±ìŠ¤ì— ë°°ì—´ì„ ë§Œë“¤ì–´ ë‚´ë¶€ ë°°ì—´ì— ì—¬ëŸ¬ê°€ì§€ë¥¼ ê³µë™ì €ì¥ì„ ì‹œí‚¤ëŠ” ê²ƒì„
        - ë‚´ë¶€ ë°°ì—´ì— ê°’ì´ ë§ìœ¼ë©´ ì‹œê°„ì´ ë” ê±¸ë¦¬ê²Œ ë¨
        - í…Œì´ë¸”(ì €ì¥í•˜ë ¤ëŠ” ë°°ì—´)ì˜ ê¸¸ì´ë³´ë‹¤ ë” ë§ì´ ì €ì¥í•  ìˆ˜ ìˆê²Œ ë¨
- Linear probing(ì§ì„  íƒìƒ‰ë²•)
    - ê° ìœ„ì¹˜ì— ë°ì´í„°í•˜ë‚˜ë§Œ ì €ì¥í•œë‹¤ëŠ” ê·œì¹™ì„ ì§€í‚¤ê¸° ìœ„í•´ ì €ì¥í•˜ë ¤ëŠ” ë°°ì—´ì˜ ì¸ë±ìŠ¤ì— ê°’ì´ ìˆìœ¼ë©´ ë‹¤ìŒìœ¼ë¡œ ë¹„ì–´ìˆëŠ” ì¸ë±ìŠ¤ë¥¼ ì°¾ì•„ ì €ì¥í•˜ëŠ” ë°©ë²•
        - ì €ì¥í•˜ë ¤ëŠ” ë°°ì—´ì˜ í¬ê¸°ê°€ ëŠ˜ì–´ë‚˜ì•¼í•˜ëŠ” ê²½ìš°ê°€ ë°œìƒí•¨.
        

## Hash table Class

- set
    - í‚¤ë‘ ê°’ì„ ë°›ìŒ
    - í‚¤ë¥¼ í•´ì‹± í•¨
    - separate chaining ì„ í†µí•´ í•´ì‹œí…Œì´ë¸” ë°°ì—´ì— í‚¤ë‘ ê°’ì„ ì €ì¥í•¨
- get
    - í‚¤ë¥¼ ë°›ìŒ
    - í‚¤ë¥¼ í•´ì‹± í•¨
    - í•´ì‹±í•œ í‚¤ ê°’ì„ í†µí•´ í•´ë‹¹í•˜ëŠ” ë°°ì—´ì˜ ì¸ë±ìŠ¤ë¡œ ê°€ì„œ ê°’ì„ ê°€ì ¸ì˜´
        - í•˜ë‚˜ ì´ìƒì´ ì €ì¥ë˜ì–´ ìˆëŠ” ì¸ë±ìŠ¤ë©´ í•´ë‹¹ ì¸ë±ìŠ¤ì˜ ì¤‘ì²© ë°°ì—´ì— ì €ì¥ë˜ì–´ìˆëŠ” ê²ƒì„ íšŒë¬¸ëŒë©´ì„œ ì°¾ì•„ì˜´
- Keys
    - í…Œì´ë¸”ì— ìˆëŠ” ëª¨ë“  í‚¤ë¥¼ í¬í•¨í•œ ëª©ë¡ì„ ì¶œë ¥í•¨
- Values
    - í…Œì´ë¸”ì— ìˆëŠ” ëª¨ë“  ê°’ì„ í¬í•¨í•œ ëª©ë¡ì„ ì¶œë ¥í•¨
        - ê²¹ì¹˜ëŠ” ê°’ë“¤ì„ ì–´ë–»ê²Œ ë³´ì—¬ì¤„ê²ƒì¸ì§€ê°€ ê´€ê±´

```jsx
class HashTable {
	constructor(size=17) {
		this.keyMap = new Array(size);
	}

	_hash(key) {
		let total = 0;
		let WEIRD_PRIME = 31;
		for(let i = 0; i < Math.min(100, key.length); i++){
			let char = key[i];
			let value = char.charCodeAt(0) - 96;
			total = (total * WEIRD_PRIME + value) % this.keyMap.length;
		}
		return total;
	}

	set(key,value) {
		let index = this._hash(key);
		//do seprate chaining
		if(!this.keyMap[index]){
			this.keyMap[index] = [];
		}
//ëŒ€ë¶€ë¶„ì˜ ì–¸ì–´ë¼ë©´ ê°™ì€ í‚¤ë¥¼ ê°€ì§€ëŠ” ê²½ìš° ì¶”í›„ì— ë“¤ì–´ì˜¨ ë°ì´í„°ë¡œ ì—…ë°ì´íŠ¸ê°€ ë˜ëŠ” ë¡œì§ì´ ë˜ì–´ì•¼í•¨
//í˜„ì¬ëŠ” ì²˜ìŒ ë“¤ì–´ì˜¨ ê°’ì„ ê·¸ëŒ€ë¡œ ìœ ì§€í•˜ê³  ì¤‘ì²© ë°°ì—´ì— ë™ì¼ í‚¤ê°’ì˜ ë‹¤ë¥¸ ê°’ì„ ê°€ì§„ ë°°ì—´ì„ ë„£ì–´ì¤Œ
//getì„ ì‚¬ìš©ì‹œ ì²˜ìŒ ë“¤ì–´ì˜¨ ë°ì´í„°ë§Œì„ ê³„ì† ë°˜í™˜í•˜ê³  ìˆê²Œ ë¨
//ë‚˜ì¤‘ì— í•„ìš”í•˜ë©´ ë¡œì§ ë³€ê²½í•´ë„ ë ë“¯ 
		this.keyMap[index].push([key,value]);
	}

	get(key) {
		let index = this._hash(key);
		if(this.keyMap[index]){
			for(let i = 0; i < this.keyMap[index].length; i++){
				if(this.keyMap[index][i][0] === key) {
					return this.keyMap[index][i][1];
				}
			}
		}

		return undefined;
	}

	values(){
		let keysArr = [];
		for(let i = 0; i < this.keyMap.length; i++){
			if(this.keyMap[i]){
				for(let j = 0; j < this.keyMap[i].length; j++){
					if(!keysArr.includes(this.keyMap[i][j][0])){
						keysArr.push(this.keyMap[i][j][0])
					}				
				}
			}
		}
		return keysArr;
	}

	values(){
		let valuesArr = [];
		for(let i = 0; i < this.keyMap.length; i++){
			if(this.keyMap[i]){
				for(let j = 0; j < this.keyMap[i].length; j++){
					if(!valuesArr.includes(this.keyMap[i][j][1])){
						valuesArr.push(this.keyMap[i][j][1])
					}				
				}
			}
		}
		return valuesArr;
	}
}
```

### Big O Of Hash Tables

Average Case

- Insert: O(1)
- Deletion: O(1)
- Access: O(1)

Worst Case

í•´ì‹œí•¨ìˆ˜ê°€ ì“°ë ˆê¸°ë¼ì„œ ë°°ì—´ì— í•˜ë‚˜ì˜ ì¸ë±ìŠ¤ì—ë§Œ ê°’ì´ ê³„ì† ë“¤ì–´ê°€ëŠ” ê²½ìš°ê°€ í•´ë‹¹ë  ìˆ˜ ìˆìŒ.

ê·¸ëŸ¬ë©´ ì‚½ì… ì œê±° ì ‘ê·¼ ëª¨ë‘ì—ì„œ í•˜ë‚˜ì˜ ì¸ë±ìŠ¤ì— ëª¨ë“  ë°ì´í„°ë¥¼ íšŒë¬¸í•´ì•¼ í•˜ëŠ” ìƒí™©ì´ ìƒê²¨ O(N)ì´ ë  ìˆ˜ë„ ìˆìŒ.

- Insert: O(N)
- Deletion: O(N)
- Access: O(N)

# ê·¸ë˜í”„(Graph)

- ìœ í•œí•˜ê³  ë³€í•  ìˆ˜ ìˆëŠ” ê¼­ì§€ì ì´ë‚˜ ë…¸ë“œë‚˜ ì ë“¤ì˜ ì§‘í•©ìœ¼ë¡œ êµ¬ì„±ëœ ë°ì´í„° êµ¬ì¡°
- ì‰½ê²Œ ìƒê°í•˜ë©´ Nodes(ë…¸ë“œ) + Connections(ì—°ê²°)ì„ ëª¨ì€ ê²ƒì„ ê·¸ë˜í”„ë¼ê³  ë³´ë©´ ë¨

## ê·¸ë˜í”„ ì‚¬ìš© ì²˜

- ê±°ì˜ ëŒ€ë¶€ë¶„
    - Social Networks
    - ìœ„ì¹˜/ ì§€ë„
    - ë¼ìš°íŒ… ì•Œê³ ë¦¬ì¦˜
    - ê¸¸ì°¾ê¸°
    - ì œí’ˆ ì¶”ì²œ
    - íŒŒì¼ì‹œìŠ¤í…œ ìµœì í™” ë“± ..

## ìš©ì–´

- Vertex: ì •ì  === ë…¸ë“œ
- Edge : ë…¸ë“œ(ì •ì )ì‚¬ì´ì˜ ì—°ê²°
    - íŠ¸ë¦¬ëŠ” í•˜ë‚˜ì˜ ë…¸ë“œì—ì„œ ë‹¤ë¥¸  ë…¸ë“œë¡œ ê°ˆë ¤ë©´ í•˜ë‚˜ì˜ ê²½ë¡œë§Œ ì¡´ì¬í•´ì•¼ í•¨
- Weighted/ Unweighted:  ì‹œê°ì ìœ¼ë¡œ ì •ì ì‚¬ì´ì— ê±°ë¦¬ê°€ ê¸°ì¬ë˜ì–´ ìˆëŠ” ê²½ìš°ì˜ ì—¬ë¶€
    - Edgeì— ê°€ì¤‘ì¹˜ê°€ ìˆëŠ” ê²½ìš°ë¼ê³  ìƒê°í•˜ë©´ ë¨
- Directed/ Undirected: ì •ì ì‚¬ì´ì— ë°©í–¥ì´ í• ë‹¹ë˜ì–´ ìˆëŠ” ê²½ìš°ì˜ ì—¬ë¶€
    - Undirected: ì–‘ê·¹/ìŒê·¹ì´ ì—†ìŒ(ì–‘ë°©í–¥ ì—°ê²°ì¸ ê²½ìš° Bâ†’A ê°€ëŠ¥, Aâ†’B ê°€ëŠ¥)
        - í˜ë¶ íŒ”ë¡œìš° ìš”ì²­ì„ ìƒê°í•´ë³´ë©´ ë¨(ìˆ˜ë½í•˜ë©´ ì„œë¡œì˜ í˜ì´ì§€ ë³´ê¸° ê°€ëŠ¥)
    - Directed: Aâ†’B ê°€ëŠ¥ Bâ†’Aë¶ˆê°€ëŠ¥ê³¼ ê°™ì´ ì–‘ë°©í–¥ ì—°ê²°ì´ ì•„ë‹Œ ê²½ìš°(ê°„ì„ ì— ë°©í–¥ì´ ë¶€ì—¬ë¨)
        - ì¸ìŠ¤íƒ€ê·¸ë¨ íŒ”ë¡œìš°ë¥¼ ìƒê°í•´ë³´ë©´ ë³´ê³  ì‹¶ì€ ì‚¬ëŒë§Œ íŒ”ë¡œìš°í•´ì„œ ë³´ê²Œ ë¨
        

## ê·¸ë˜í”„ ëª¨ë¸ë§

ì‹¤ì œ ì •ì (Vertex)ë“¤ê³¼ ì—°ê²°(Edge)ì„ ì €ì¥í•œë‹¤ëŠ” ê²ƒì´ ì¤‘ìš”í•˜ë‹¤ëŠ” ìƒê°ì„ ê°€ì ¸ë³´ì

### 1. ì¸ì ‘ í–‰ë ¬ ë°©ë²•(Adgacency Matrix)

- ì—°ê²°ëœ ë¶€ë¶„ë“¤ì€ 1ë¡œ ì—°ê²°ì•ˆëœ ë¶€ë¶„ë“¤ì„ 0ìœ¼ë¡œ ê°„ë‹¨í•˜ê²Œ ìƒê°í•˜ì(booleanë“±ìœ¼ë¡œ í‘œí˜„í•´ë„ ë¨)
- ì´ì°¨ì› í–‰ë ¬ ìƒê°í•˜ë©´ ë¨

```jsx
			/*A B C D E F*/
/*A*/ [[0,1,0,0,0,1],
/*B*/ [1,0,1,0,0,0],
/*C*/ [0,1,0,1,0,0],
/*D*/ [0,0,1,0,1,0],
/*E*/ [0,0,0,1,0,1],
/*F*/ [1,0,0,0,1,0]]
```

### 2. ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ë°©ì‹(Adgacency List)

- ì´ì°¨ì› ë°°ì—´ì„ ì¨ì„œ ê° ì¸ë±ìŠ¤ê°€ ê° ë…¸ë“œì˜ ê°’ì„ ì˜ë¯¸í•˜ê³ 
    - í•´ë‹¹ ë…¸ë“œê°€ ì—°ê²°ë˜ì–´ìˆëŠ” ë…¸ë“œì˜ ì¸ë±ìŠ¤ë¥¼ ì¤‘ì²© ë°°ì—´ë¡œ ë„£ì–´ì£¼ëŠ” ë°©ì‹

```jsx
[[1,5],[0,2],[1,3],[2,4],[3,5],[4,0]]
```

- ìˆ«ìê°€ ì•„ë‹Œ ìì˜ì ì¸(ì´ë¦„ ë¬¸ìì—´ ë“±)ì¸ ì •ì  ê°’ì„ ê°€ì§„ ê²½ìš° í•´ì‹œí…Œì´ë¸”ì„ ì‚¬ìš©í•´ì„œ Key, Value ë°ì´í„°êµ¬ì¡°ë¡œ ê°€ë©´ ë¨
    
    ```jsx
    {
    	A: ["B", "F"],
    	B: ["A", "C"],
    	C: ["B","D"],
    	D: ["C","E"],
    	E: ["D", "F"],
    	F: ["E", "A"]
    }
    ```
    

### ë‘ê°€ì§€ ë°©ì‹ì˜ ì°¨ì´ì  & BIG O

ì°¨ì´ì 

| ë¹„ê³  | Adgacency Matrix | Adgacency List |
| --- | --- | --- |
| ë©”ëª¨ë¦¬ | ë” ë§ì€ ê³µê°„ì„ ì‚¬ìš©í•¨(í¼ì ¸ ìˆëŠ” ê·¸ë˜í”„ì—ì„œ) | ë¹„êµì  ì ì€ ê³µê°„ì„ ì‚¬ìš©í•¨(í¼ì ¸ ìˆëŠ” ê·¸ë˜í”„ì—ì„œ) |
| ê°„ì„ ìˆœíšŒ | ëª¨ë“  ê°„ì„ ì„ ìˆœíšŒí•˜ëŠ” ê²ƒì´ ë¹„êµì  ëŠë¦¼ | ëª¨ë“  ê°„ì„ ì„ ìˆœíšŒ í•˜ëŠ” ê²ƒì´ ë¹„êµì  ë¹ ë¦„ |
| ê°„ì„  ì°¾ê¸° | íŠ¹ì •ê°„ì„ ì„ ì°¾ëŠ” ê²ƒì´ ë¹„êµì  ë¹ ë¦„ | íŠ¹ì • ê°„ì„ ì„ ì°¾ì•„ë‚´ëŠ” ê²ƒì´ ë¹„êµì  ëŠë¦¼ |

Big O

- V:  ì •ì  ê°œìˆ˜(ì ˆëŒ€ê°’)
- E: ê°„ì„  ê°œìˆ˜(ì ˆëŒ€ê°’)

| Operation | Adgacency Matrix | Adgacency List |
| --- | --- | --- |
| Add Vertex(ì •ì  ì¶”ê°€) | O(V^2) | O(1) |
| Add Edge(ê°„ì„  ì¶”ê°€) | O(1) | O(1) |
| Remove Vertex(ì •ì  ì œê±°) | O(V^2) | O(V+E) |
| Remove Edge(ê°„ì„  ì œê±°) | O(1) | O(E) |
| Query | O(1) | O(V+E) |
| Storage | O(V^2) | O(V+E) |

ì°¨ì§€í•˜ëŠ” ê³µê°„ ë•Œë¬¸ì— ì¸ì ‘ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ì¼€ì´ìŠ¤ê°€ ë§ì„ ê²ƒ.

 ëŒ€ë¶€ë¶„ì˜ ì‹¤ì œ ë°ì´í„°ë“¤ì´ ë…¸ë“œì˜ ê°œìˆ˜ ì •ì ì˜ ê°œìˆ˜ëŠ” ë§ì§€ë§Œ ì„œë¡œ ë‹¤ ì—°ê²°ë˜ì–´ ìˆì§€ ì•Šì€ê²½ìš°ê°€ ë” ë§ìŒ.

ê·¸ë˜ì„œ Matrixë°©ì‹ìœ¼ë¡œ ë§Œë“¤ë©´ ì—°ê²°ë˜ì§€ ì•Šì€ê²ƒë„ ì¤‘ì²©ë°°ì—´ë¡œ ë³´ì—¬ì£¼ê¸°ì— ë„ˆë¬´ ì“¸ë° ì—†ì´ ë§ì€ê³µê°„ì„ ì‚¬ìš©í•  ìˆ˜ë„ ìˆê²Œ ë¨.

ë§Œì•½ ë°ì´í„°ê°€ ì§‘ì•½ì ì´ê³  ëŒ€ë¶€ë¶„ ì—°ê²°ë˜ì–´ ìˆë‹¤ë©´ Matrixë°©ì‹ì´ ì¢‹ì„ ê²ƒ.

## Graph Class

## Skeleton

ë¬´ë°©í–¥(ì–‘ë°©í–¥) ê·¸ë˜í”„ + ì¸ì ‘ë¦¬ìŠ¤íŠ¸ ë°©ì‹ì„ ì‚¬ìš©í•  ê²ƒì„.

```jsx
class Graph {
	constructor(){
			this.adjacencyList = {}	
	}
}
```

## Add Vertex method

- ì •ì ì˜ ì´ë¦„ì„ ì¸ìë¡œ ë°›ê³ 
- ì´ ì´ë¦„ì„ ì •ì ì˜ ì´ë¦„ìœ¼ë¡œ ì •í•˜ê³  ì¸ì ‘ë¦¬ìŠ¤íŠ¸ì˜ í‚¤ë¡œ ì…ë ¥í•˜ê²Œ ë¨
    - ê°’ì€ ë¹ˆ ë°°ì—´ë¡œ ì •í•˜ë©´ ë¨.

```jsx
addVertex(vertex) {
	if(this.adjacencyList[vertex]) return "Existing Vertex"
	this.adjacencyList[vertex] = [];
}
```

## Add Edge method

- ë‘ê°œì˜ ì¸ìˆ˜ë¥¼ ë°›ì„ ê²ƒì„(Vertex1, Vertex2)
- adjacencyListì—ì„œ vertex1ì˜ í‚¤ë¥¼ ì°¾ì•„ì„œ vertex2ë¥¼ ê·¸ ë°°ì—´ì— ë„£ì–´ì£¼ê³ 
    - vertex2ì˜ í‚¤ë¥¼ ì°¾ì•„ì„œ ê°’ì— vertex1ì˜ í‚¤ë¥¼ ì°¾ì•„ ë„£ì–´ì£¼ë©´ ë¨
    

```jsx
addEdge(v1, v2) {
	if(!this.adjacencyList[v1] || !this.adjacencyList[v2]){
		 return "There is no Vertex";
	};
	if(this.adjacencyList[v1].includes(v2)) return "Already Connect";
	this.adjacencyList[v1].push(v2);
	this.adjacencyList[v2].push(v1);
}
```

## Remove Edge Method

- ë‘ê°œì˜ ì¸ìˆ˜ë¥¼ ë°›ì„ ê²ƒì„(Vertex1, Vertex2)
- V1ì—ì„œëŠ” V2ë¥¼ ì œì™¸í•œ ë°°ì—´ë“¤ì„ ë‹¤ì‹œ ë¶€ì—¬í•˜ê³  V2ë„ ë˜‘ê°™ì´ í•¨
- ì—ëŸ¬í•¸ë“¤ë§ì€ ê±´ë„ˆë›´ë‹¤ê³  í•¨

```jsx
removeEdge(vertex1, vertex2) {
	if(!this.adjacencyList[vertex1] || !this.adjacencyList[vertex2]){
		 return "There is no Vertex";
	};
	this.adjacencyList[vertex1] = 	this.adjacencyList.filter((v) => v !== vertex2);
	this.adjacencyList[vertex2] = 	this.adjacencyList.filter((v) => v !== vertex1);
}
```

## Remove Vertex

- ì§€ìš°ê³   ì‹¶ì€ Vertex ì´ë¦„ ì¸ìë¡œ ë°›ìŒ
- íšŒë¬¸ëŒë©´ì„œ ë‹¤ë¥¸ Vertexì˜ ë°°ì—´ì—ì„œ ëª¨ë‘ ì´ ì´ë¦„ì„ ë‹¤ ì§€ì›Œì£¼ë©´ ë¨
    - removeEdge í•¨ìˆ˜ë¥¼ í™œìš©í•  ê²ƒì„
    - ë§ˆì§€ë§‰ìœ¼ë¡œ adjacencyListì—ì„œ í•´ë‹¹ Vertexí‚¤ë¥¼ ì‚­ì œí•´ì£¼ë©´ ë¨

```jsx
removeEdge(vertex){
	if(!this.adjacencyList[vertex]){
		 return "There is no Vertex";
	};

	while(this.adjacencyList[vertex].length) {
		//ë¬´ë°©í–¥(ì–‘ë°©í–¥) ê·¸ë˜í”„ë¼ ì´ë ‡ê²Œ ê°€ëŠ¥
		const adjacentVertex = this.adjacencyList[vertex].pop();
		this.removeEdge(vertex, adjacentVertex);
		delete this.adjacencyList[vertex];
	}
}
```

## ê·¸ë˜í”„ ìˆœíšŒ(Graph Travesal)

- ë£¨íŠ¸ê°€ ì¡´ì¬í•˜ëŠ” íŠ¸ë¦¬ì™€ëŠ” ë‹¤ë¥´ê²Œ ê·¸ë˜í”„ì—ì„œëŠ” ìˆœíšŒë¥¼ ì‹œì‘í•˜ëŠ” ì§€ì ì„ ì„ì˜ë¡œ ì •í•´ì¤˜ì•¼ í•¨.

## ê·¸ë˜í”„ ìˆœíšŒ ì‚¬ìš©ì²˜

- í† ë Œí†  ê°™ì€ ì›¹ì‚¬ì´íŠ¸(Peer to Peer networking), ì›¹ í¬ë¡¤ëŸ¬, ê°€ì¥ ê°€ê¹Œìš´ê²ƒ ì°¾ê¸° ë˜ëŠ” ì¶”ì²œ
- ìµœì†Œê±°ë¦¬ ê¸¸ ì°¾ê¸°
    - GPS, ë¯¸ë¡œì°¾ê¸°, AI

## DFS

- â€œBacktrackingâ€ì„ í•˜ê¸° ì „ê¹Œì§€ ìµœëŒ€í•œ ì•„ë˜ë¡œ ë‚´ë ¤ê°€ë©° íƒìƒ‰í•˜ëŠ” ê²ƒ.
- ì „ìœ„, í›„ìœ„, ì •ìœ„ê°€ ì´ì§„íŠ¸ë¦¬íƒìƒ‰ì‹œ ì—ëŠ” ìˆì—ˆìŒ.
- í˜•ì œë¥¼ ë¨¼ì € íƒìƒ‰í•˜ëŠ”ê²Œ ì•„ë‹ˆë¼ ìì‹ë…¸ë“œë¥¼ ë¨¼ì € íƒìƒ‰í•¨
- ë£¨íŠ¸ëŠ” ê·¸ë¦¬ê¸°ì— ë”°ë¼ ë³´ê¸° ìˆœíšŒë¥¼ í™•ì¸í•˜ê¸° í˜ë“¤ ìˆ˜ë„ ìˆì§€ë§Œ ì²˜ìŒì‹œì‘ì (ë£¨íŠ¸)ì—ì„œ ë©€ì–´ì§€ëŠ” ë°©ì‹ìœ¼ë¡œ ì´í•´í•˜ë©´ í¸í•¨
    - ì¸ì ‘ì ì„ ë”°ë¼ê°€ê³  ë”°ë¼ê°€ì„œ ê¸¸ì´ë§‰íë•Œ ê¹Œì§€ ê°€ëŠ”ê²ƒì„
        - ë§‰í˜€ìˆìœ¼ë©´ ê·¸ ì „ìœ¼ë¡œ ëŒì•„ì™€ ë°©ë¬¸í•˜ì§€ ì•Šì€ ê²ƒì„ ë‹¤ì‹œ ë°©ë¬¸

ì˜ˆì‹œ

```jsx
{
	"A": ["B","C"],
	"B": ["A","D"],
	"C": ["A","E"],
	"D": ["B","E","F"],
	"E": ["C","D","F"],
	"F": ["D","E"],
}
//[A,B,D,E,C,F]
```

ì•ŒíŒŒë²³ ìˆœìœ¼ë¡œ ë°©ë¬¸í•œë‹¤ê³  ê°€ì •í•´ë³´ì

Aë¨¼ì € ë°©ë¬¸í–ˆë‹¤ê³  ì¹˜ê³  â†’ ì¸ì ‘ì ì€ C, Bê°€ ìˆìŒ â†’Bë¨¼ì € ë°©ë¬¸ â†’ Bì˜ ì¸ì ‘ì ì€ A,Dê°€ ìˆìŒ â†’ AëŠ” ì´ë¯¸ ë°©ë¬¸í–ˆìœ¼ë¯€ë¡œ Dë¡œ ë°©ë¬¸ â†’ DëŠ” B,E,Fì˜ ì¸ì ‘ì ì„ ê°€ì§€ëŠ”ë° BëŠ” ì´ë¯¸ ë°©ë¬¸í–ˆìœ¼ë¯€ë¡œ Eë¡œ ê° â†’ EëŠ” C,D,Fì˜ ì¸ì ‘ì ì´ ìˆê³  DëŠ” ì´ë¯¸ ë°©ë¬¸í–ˆìœ¼ë¯€ë¡œ Cë¡œ ë°©ë¬¸ â†’ **Cì˜ ì¸ì ‘ì ì€ ëª¨ë‘ ë°©ë¬¸ â†’ Eë¡œ ë‹¤ì‹œ ëŒì•„ì™€ì„œ â†’ Eì—ì„œ ë¯¸ë°©ë¬¸í•œ Fë¡œ ë°©ë¬¸**

### Recursive DFS pseudo

```jsx
DFS(vertex):
		if vertex is empty
			return (this is base case)
		add vertex to results list
		mark vertex as visited
		for each neighbor in vertex's neigbor:
		if neighbor is not visited:
			recursively call DFS on neighbor
```

- ì‹œì‘ì ì˜ ë…¸ë“œë¥¼ ì¸ìë¡œ ë°›ìŒ
- ë¹ˆ ë¦¬ìŠ¤íŠ¸, ë°°ì—´ì„ ë§Œë“¤ì–´ ìµœì¢…ê²°ê³¼ë¥¼ ì €ì¥ ê·¸ë¦¬ê³  ë§ˆì§€ë§‰ì— ë±í™˜
- ì •ì ì„ ì €ì¥í•  ìˆ˜ ìˆëŠ” ë°©ë¬¸ê°ì²´ë¥¼ ë§Œë“¦(ë°©ë¬¸í™•ì¸)
- ì •ì (vertex)ë¥¼ ì…ë ¥í•˜ëŠ” DFSí•¨ìˆ˜(helper function)ë¥¼ ë§Œë“¦
    - ì •ì ì´ ë¹„ì–´ìˆìœ¼ë©´ ê± ë¦¬í„´ì‹œí‚´(ëëƒ„)
    - ì…ë ¥í•œ ì •ì ì„ ë°©ë¬¸ê°ì²´ì— ë„£ì–´ ë°©ë¬¸í‘œì‹œë¥¼ í•´ì£¼ê³  ê²°ê³¼ ë°°ì—´ì— ë°©ë¬¸í•œ ì •ì ì„ ë„£ì–´ì¤Œ
    - í•´ë‹¹ ì •ì ì˜ ëª¨ë“  ë°©ë¬¸í•˜ì§€ ì•Šì€ ì¸ì ‘ì ì— ëŒ€í•´ DFSí•¨ìˆ˜(helper function)ë¥¼ ì´ìš©í•´ ì¬ê·€ë¥¼ ëŒë¦¼
- DFSí•¨ìˆ˜ë¥¼ ì‹¤í–‰í•¨(helper function)
- ê²°ê³¼ ë°°ì—´ or ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•¨

### Recursive DFS

```jsx
depthFirstRecursive(start) {
	const result = [];
	const visited = {};
	const adjacencyList = this.adjacencyList;

	const dfs = (vertex) => {
		if(!vertex) return null;
		//ë°©ë¬¸ì²˜ë¦¬
		visited[vertex] = true;
		//ë°©ë¬¸ê²°ê³¼ ë°°ì—´ì— ë‹´ìŒ
		result.push(vertex);
		//í•´ë‹¹ ì •ì ê³¼ ì—°ê²°ëœ ì •ì ë“¤ì— ë°©ë¬¸í•˜ì§€ ì•Šì€ ê²ƒë“¤ì€ 
		//ì¬ê·€ë¥¼ í†µí•´ ë°©ë¬¸ì²˜ë¦¬ë¥¼ í•˜ê²Œ ë§Œë“¦
		adjacencyList[vertex].forEach((neighbor)=>{
			if(!visited[neighbor]) return dfs(neighbor);
		})
	}

	//ì¬ê·€ ì‹œì‘
	dfs(start);
	//ê²°ê³¼ ë°˜í™˜
	return result;
}
{
	"A": ["B","C"],
	"B": ["A","D"],
	"C": ["A","E"],
	"D": ["B","E","F"],
	"E": ["C","D","F"],
	"F": ["D","E"],
}

//  A
// /  \
//B    C
//|    |
//D -- E
// \  /
//   F

//result = [A,B,D,E,C,F]
```

### Iterative DFS

```jsx
DFS-Iterative(start):
	let S be a stack //
	S.push(start)
	while S is not empty
		vertex = s.pop();
		if vertex is not labled as discovered:
			visit vertex(add to result list);
			label vertex as discovered
			for each of vertex's neighbors, N do
				S.push(N);			
```

- ì‹œì‘ì ì˜ ë…¸ë“œë¥¼ ì¸ìë¡œ ë°›ìŒ
- ë¹ˆ ë¦¬ìŠ¤íŠ¸, ë°°ì—´ì„(stack) ë§Œë“¤ì–´ ìµœì¢…ê²°ê³¼ë¥¼ ì €ì¥ ê·¸ë¦¬ê³  ë§ˆì§€ë§‰ì— ë±í™˜
- ì •ì ì„ ì €ì¥í•  ìˆ˜ ìˆëŠ” ë°©ë¬¸ê°ì²´ë¥¼ ë§Œë“¦(ë°©ë¬¸í™•ì¸)
- start ì •ì ì„ stackì— ë„£ê³  ë°©ë¬¸ì²˜ë¦¬í•¨
- ìŠ¤íƒì´ ë¹Œë•Œê¹Œì§€ while ë£¨í”„ë¥¼ ëŒë¦¼
    - stackì—ì„œ ë‹¤ìŒ ì •ì (vertex)ì„ popí•¨
    - ì •ì ì´ ë°©ë¬¸ì²˜ë¦¬ ë˜ì–´ìˆì§€ ì•Šìœ¼ë©´
        - ë°©ë¬¸ì²˜ë¦¬í•˜ê³ 
        - ê²°ê³¼ë¥¼ ë°˜í™˜í•  ë°°ì—´ì— ë„£ì–´ì£¼ê³ 
        - ê·¸ ì´ì›ƒë“¤(ì—°ê²°ëœ ì •ì ë“¤)ì„ stackì— ë‹¤ ë„£ì–´ì¤Œ
- ê²°ê³¼ ë°°ì—´(result)ë¥¼ ë°˜í™˜í•¨

```jsx
depthFirstIterative(start) {
	const visited = {};
	const result = [];
	//ì‹œì‘ì  ë„£ê³  ë°©ë¬¸ì²˜ë¦¬
	const stack = [start];
	visited[start] = true;
	let currentVertex;
	
	while(stack.length) {
		currentVertex = stack.pop();	
		result.push(currentVertex);
		this.adjacencyList[currentVertex].forEach((neighbor)=>{
			if(!visited[neighbor]){
				visitied[neighbor] = true;
				stack.push(neighbor);
			}
		})
	}
	return result;
}
//ìˆœí™˜í˜•
//["A","C","E","F","D","B"]
//ì¬ê·€í˜•
//[A,B,D,E,C,F]
//ìˆœì„œê°€ ë‹¤ë¥¸ ì´ìœ ëŠ” ì‘ë™ë°©ì‹ì´ ë‹¤ë¥´ê¸° ë•Œë¬¸ ê·¸ëŸ¬ë‚˜ DFSë¥¼ ì‹¤í–‰í•œê²ƒì€ ë˜‘ê°™ìŒ
/*
Iterative ë°©ì‹ì—ì„œëŠ” stackì„ ì‚¬ìš©í•˜ì—¬ pushí•œ ë’¤ 
popì„ í•˜ê¸° ë•Œë¬¸ì— ì¬ê·€ ë°©ì‹ê³¼ ë‹¤ë¥´ê²Œ ì¸ì ‘ ì •ì ì˜ 
ìˆœì„œê°€ ë’¤ì§‘íˆê¸° ë•Œë¬¸ì— ë‹¤ë¥´ê²Œ ë¨
*/
```

## BFS

- ì•„ë˜ë¡œ ë‚´ë ¤ê°€ê±°ë‚˜ ì¸ì ‘ì ì˜ ì¸ì ‘ì ì„ ë³´ê²Œ ë˜ëŠ” íƒìƒ‰
- íŠ¸ë¦¬ì²˜ëŸ¼ ì‰½ê²Œ ìˆ˜ì§ ìˆ˜í‰ì„ ë‚˜ëˆ„ì§€ëŠ” ëª»í•˜ì§€ë§Œ ë ˆë²¨ì´ ì¡´ì¬í•¨ â†’ heightë¼ê³  ë¶€ë¦„
- BFSëŠ” ë‹¤ìŒ ë†’ì´ì˜ ì¸ì ‘ì ì„ ë°©ë¬¸í•˜ê¸° ì „ì— ë™ì¼ ë ˆë²¨ì˜ ì¸ì ‘ì ì„ ë‹¤ ë°©ë¬¸í•œë‹¤ê³  ìƒê°í•˜ë©´ ë¨.
- DFSì˜ ìŠ¤íƒ ëŒ€ì‹  BFSëŠ” íë¥¼ ì‚¬ìš©í•¨

### BFS pseudo code

- start ì •ì ì„ ë°›ìŒ
- íë¥¼ ë§Œë“¤ì–´ì„œ startì •ì ì„ ë„£ì–´ì¤Œ(ë°°ì—´ì¨ì„œ ë©”ì„œë“œë§Œ ë°”ê¿”ì„œ í ì²˜ëŸ¼ ì‚¬ìš©)
- resultë°°ì—´ì— ë„£ì–´ì¤Œ
- ì •ì ì´ ë°©ë¬¸í•œê²ƒì„ ì²´í¬í•  Objë¥¼ ë§Œë“¤ì–´ ì²´í¬í•´ì¤Œ
- íê°€ ë¹Œ ë•Œ ê¹Œì§€ whileëŒë¦¼
- queueì—ì„œ ì²«ë²ˆì§¸ ì •ì  í•˜ë‚˜ ë¹¼ì˜¨ ë’¤ ë°©ë¬¸í•œ ë°°ì—´ì— ë„£ì–´ì¤Œ
- í•´ë‹¹ ì •ì ì— ìˆëŠ” ê° ì¸ì ‘ì (ì¸ì ‘ë¦¬ìŠ¤íŠ¸)ì— ìˆëŠ” ëª¨ë“  ì¸ì ‘ì ì— ëŒ€í•´ ë£¨í•‘ì„ ëŒë¦¬ë©° ë°©ë¬¸í•˜ì§€ ì•Šì€ ê²½ìš° ë°©ë¬¸ì²˜ë¦¬ í•˜ê³  ê²°ê³¼ ë°°ì—´ì— ë„£ì–´ ì¤Œ
    - ê±°ì˜ dfsë‘ ë¹„ìŠ·í•œë° queueë¥¼ ì“°ëŠ”ê±¸ ìœ ì˜í•˜ë©´ ë  ë“¯.
- ë§¨ ë§ˆì§€ë§‰ì— resultë°°ì—´ì„ ë°˜í™˜í•´ì¤Œ

### BFS

```jsx
breadthFirst(start) {
	const queue = [start];
	const result =[];
	const visited = {};
	let currentVertex;
	visited[start] = true;

	while(queue.length){
		currentVertex = queue.shift();
		result.push(currentVertex);

		this.adjacencyList[currentVertex].forEach((neighbor)=> {
			if(!visited[neighbor]){
				visited[neighbor] = true;
				queue.push(neighbor);
			}
		})
	}
	return result;
}
/*
{
	"A": ["B","C"],
	"B": ["A","D"],
	"C": ["A","E"],
	"D": ["B","E","F"],
	"E": ["C","D","F"],
	"F": ["D","E"],
}
*/
//  A
// /  \
//B    C
//|    |
//D -- E
// \  /
//   F
//[A,B,C,D,E,F]
```

# ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜

- ë‹¤ìµìŠ¤íŠ¸ë¼ ìµœë‹¨ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ì˜ ì¤„ì„ë§ì´ê³  ë˜ê²Œ ìœ ëª…í•¨
- ì ¤ ìœ ëª…í•œ ìµœë‹¨ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ ì¤‘ í•˜ë‚˜ì„.
- ê·¸ë˜í”„ë¥¼ ê°€ë¡œì§€ë¥´ë©° íƒìƒ‰ì„ í•˜ê²Œ ë¨
- ìš°ì„ ìˆœìœ„ íë¥¼ ì‚¬ìš©í•˜ê²Œ ë¨(ì´ì§„ í™ì„ ì´ìš©í•œ ìš°ì„ ìˆœìœ„ íë¥¼ ì‚¬ìš©í•˜ë©´ ë¨ ã…ã……ã…)
- í•œ ìŠ¬ë¼ì´ë“œì— pseudoì½”ë“œë¥¼ ë„£ì„ë§Œí¼ ë‹¨ìˆœí•˜ì§€ê°€ ëª» í•¨.
- **ë‘ ì •ì ì‚¬ì´ì— ì¡´ì¬í•˜ëŠ” ìµœë‹¨ê²½ë¡œë¥¼ ì°¾ëŠ” ê²ƒ**

## ì‚¬ìš©ì²˜

- GPS - êµ¬ì‹ ìµœë‹¨ê²½ë¡œ ì°¾ê¸°(ìš”ì¦˜ì€ ë‚ ì”¨ë‚˜ ì‹¤ì œ íŠ¸ë˜í”½ ë“±ë“± ë§¤ê°œë³€ìˆ˜ê°€ í›¨ì”¬ ë§ìŒ)
- Network Routing - ë„¤íŠ¸ì›Œí¬ì—ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ìœ„í•œ ìµœë‹¨ê²½ë¡œ
- ìƒë¬¼í•™ - ì‚¬ëŒì—ê²Œ í¼ì ¸ìˆëŠ” ì „ì—¼ë³‘ ë¶„í¬ë„ ë“±..
- ë¹„í–‰ í‹°ì¼“ - ê°€ì¥ ì‹¼ ê°€ê²©ìœ¼ë¡œ ê²½ìœ í•´ì„œ ê°€ëŠ” ë²• ë“±..
- ë“±ë“±..

## ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ ì‘ì„±

```jsx
class WeightedGraph {
	constructor(){
		this.adjacencyList = {};
	}
	
	addVertex(vertex) {
		if(!this.adjacencyList[vertex]){
			 this.adjacencyList[vertex] = [];
		}
	}
	addEdge(vertex1, vertex2, weight) {
		 this.adjacencyList[vertex1].push({node: vertex2, weight});
		 this.adjacencyList[vertex2].push({node: vertex1, weight});
	}
}

const graph = new WeightedGraph();

graph.addVertex("A");
graph.addVertex("B");
graph.addVertex("C");
graph.addEdge("A","B",9);
graph.addEdge("A","C",5);
graph.addEdge("B","C",7);
console.log(graph.adjacencyList);

```